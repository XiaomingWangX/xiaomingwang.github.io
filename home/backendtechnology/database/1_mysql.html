<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>mysql</title>
    <meta name="description" content="">
    
    
    <link rel="preload" href="/assets/css/0.styles.a0ada997.css" as="style"><link rel="preload" href="/assets/js/app.a8d644b6.js" as="script"><link rel="preload" href="/assets/js/2.b0571e25.js" as="script"><link rel="preload" href="/assets/js/33.928e8282.js" as="script"><link rel="prefetch" href="/assets/js/10.c8889642.js"><link rel="prefetch" href="/assets/js/100.51a741fb.js"><link rel="prefetch" href="/assets/js/101.d9dbfe05.js"><link rel="prefetch" href="/assets/js/102.52466a3b.js"><link rel="prefetch" href="/assets/js/103.3cf394c6.js"><link rel="prefetch" href="/assets/js/104.90d3018b.js"><link rel="prefetch" href="/assets/js/105.dd9bdeef.js"><link rel="prefetch" href="/assets/js/106.6bda79d0.js"><link rel="prefetch" href="/assets/js/107.ef743f0b.js"><link rel="prefetch" href="/assets/js/108.fa92013e.js"><link rel="prefetch" href="/assets/js/109.50afa695.js"><link rel="prefetch" href="/assets/js/11.e31c3ea5.js"><link rel="prefetch" href="/assets/js/110.aad632dd.js"><link rel="prefetch" href="/assets/js/111.499096ad.js"><link rel="prefetch" href="/assets/js/112.6069b48f.js"><link rel="prefetch" href="/assets/js/113.b8841596.js"><link rel="prefetch" href="/assets/js/114.23496351.js"><link rel="prefetch" href="/assets/js/115.e08ac3c1.js"><link rel="prefetch" href="/assets/js/116.760ebdb3.js"><link rel="prefetch" href="/assets/js/117.f226c0c1.js"><link rel="prefetch" href="/assets/js/118.65289b19.js"><link rel="prefetch" href="/assets/js/119.e3cf777f.js"><link rel="prefetch" href="/assets/js/12.78a1ab5b.js"><link rel="prefetch" href="/assets/js/120.7760e751.js"><link rel="prefetch" href="/assets/js/121.05ec49dd.js"><link rel="prefetch" href="/assets/js/122.688774b7.js"><link rel="prefetch" href="/assets/js/123.06bf7f11.js"><link rel="prefetch" href="/assets/js/124.62bfda58.js"><link rel="prefetch" href="/assets/js/125.eda5b500.js"><link rel="prefetch" href="/assets/js/126.1b39c0b0.js"><link rel="prefetch" href="/assets/js/127.65be59e4.js"><link rel="prefetch" href="/assets/js/128.25fbb5dc.js"><link rel="prefetch" href="/assets/js/129.cd5e2b4b.js"><link rel="prefetch" href="/assets/js/13.6a543448.js"><link rel="prefetch" href="/assets/js/130.fcc93329.js"><link rel="prefetch" href="/assets/js/131.6d7c37d1.js"><link rel="prefetch" href="/assets/js/132.09cf25fb.js"><link rel="prefetch" href="/assets/js/133.583d15f0.js"><link rel="prefetch" href="/assets/js/134.7b72ef87.js"><link rel="prefetch" href="/assets/js/135.733d2857.js"><link rel="prefetch" href="/assets/js/136.b8649b26.js"><link rel="prefetch" href="/assets/js/137.e71138fa.js"><link rel="prefetch" href="/assets/js/138.95b4f55f.js"><link rel="prefetch" href="/assets/js/139.c09e22b6.js"><link rel="prefetch" href="/assets/js/14.819689ab.js"><link rel="prefetch" href="/assets/js/140.71186b46.js"><link rel="prefetch" href="/assets/js/141.5bb51b5a.js"><link rel="prefetch" href="/assets/js/142.94804f8e.js"><link rel="prefetch" href="/assets/js/143.7191f64e.js"><link rel="prefetch" href="/assets/js/144.d2957568.js"><link rel="prefetch" href="/assets/js/145.651e0adf.js"><link rel="prefetch" href="/assets/js/146.d0a83694.js"><link rel="prefetch" href="/assets/js/147.fc4d286f.js"><link rel="prefetch" href="/assets/js/148.410aec93.js"><link rel="prefetch" href="/assets/js/149.a453f4de.js"><link rel="prefetch" href="/assets/js/15.5bc49d67.js"><link rel="prefetch" href="/assets/js/150.77f0ea12.js"><link rel="prefetch" href="/assets/js/151.c808f32e.js"><link rel="prefetch" href="/assets/js/152.22e5d574.js"><link rel="prefetch" href="/assets/js/153.bc4da283.js"><link rel="prefetch" href="/assets/js/154.fa61ee21.js"><link rel="prefetch" href="/assets/js/155.42087f9f.js"><link rel="prefetch" href="/assets/js/156.7745074e.js"><link rel="prefetch" href="/assets/js/157.804702be.js"><link rel="prefetch" href="/assets/js/158.b6fe8f70.js"><link rel="prefetch" href="/assets/js/159.8a7a433b.js"><link rel="prefetch" href="/assets/js/16.434879fd.js"><link rel="prefetch" href="/assets/js/160.1a976dd2.js"><link rel="prefetch" href="/assets/js/161.14311375.js"><link rel="prefetch" href="/assets/js/162.6bbdd1e5.js"><link rel="prefetch" href="/assets/js/163.2c60a568.js"><link rel="prefetch" href="/assets/js/164.e7567976.js"><link rel="prefetch" href="/assets/js/165.7a2dc778.js"><link rel="prefetch" href="/assets/js/166.c9a838e8.js"><link rel="prefetch" href="/assets/js/17.14403580.js"><link rel="prefetch" href="/assets/js/18.08ac9cad.js"><link rel="prefetch" href="/assets/js/19.2c183b64.js"><link rel="prefetch" href="/assets/js/20.32bb3cb9.js"><link rel="prefetch" href="/assets/js/21.d966558e.js"><link rel="prefetch" href="/assets/js/22.c75c7c76.js"><link rel="prefetch" href="/assets/js/23.7fd7f7c3.js"><link rel="prefetch" href="/assets/js/24.36b6b4eb.js"><link rel="prefetch" href="/assets/js/25.8f357f46.js"><link rel="prefetch" href="/assets/js/26.61d906dd.js"><link rel="prefetch" href="/assets/js/27.08330a35.js"><link rel="prefetch" href="/assets/js/28.b1e01410.js"><link rel="prefetch" href="/assets/js/29.936218e3.js"><link rel="prefetch" href="/assets/js/3.3214ea23.js"><link rel="prefetch" href="/assets/js/30.c0b9efde.js"><link rel="prefetch" href="/assets/js/31.5b6e3df7.js"><link rel="prefetch" href="/assets/js/32.6374edaf.js"><link rel="prefetch" href="/assets/js/34.92067108.js"><link rel="prefetch" href="/assets/js/35.154d21dd.js"><link rel="prefetch" href="/assets/js/36.e5ad0869.js"><link rel="prefetch" href="/assets/js/37.385b33d5.js"><link rel="prefetch" href="/assets/js/38.215a6333.js"><link rel="prefetch" href="/assets/js/39.bbf6207d.js"><link rel="prefetch" href="/assets/js/4.d34ebd53.js"><link rel="prefetch" href="/assets/js/40.bc0f7c00.js"><link rel="prefetch" href="/assets/js/41.3ba84cff.js"><link rel="prefetch" href="/assets/js/42.04a42e98.js"><link rel="prefetch" href="/assets/js/43.9a5e58fa.js"><link rel="prefetch" href="/assets/js/44.ad33bbd6.js"><link rel="prefetch" href="/assets/js/45.17f6595d.js"><link rel="prefetch" href="/assets/js/46.a5afba11.js"><link rel="prefetch" href="/assets/js/47.838086e6.js"><link rel="prefetch" href="/assets/js/48.34f3613a.js"><link rel="prefetch" href="/assets/js/49.726aa7d7.js"><link rel="prefetch" href="/assets/js/5.95ea0968.js"><link rel="prefetch" href="/assets/js/50.cb833116.js"><link rel="prefetch" href="/assets/js/51.3ed1ad45.js"><link rel="prefetch" href="/assets/js/52.54cf0f85.js"><link rel="prefetch" href="/assets/js/53.513a15ca.js"><link rel="prefetch" href="/assets/js/54.48b671a4.js"><link rel="prefetch" href="/assets/js/55.4ea41ff7.js"><link rel="prefetch" href="/assets/js/56.2c85bb70.js"><link rel="prefetch" href="/assets/js/57.c4b7c57f.js"><link rel="prefetch" href="/assets/js/58.8645cbfa.js"><link rel="prefetch" href="/assets/js/59.93bb241a.js"><link rel="prefetch" href="/assets/js/6.d3d6f703.js"><link rel="prefetch" href="/assets/js/60.bb6e6605.js"><link rel="prefetch" href="/assets/js/61.286ce4e5.js"><link rel="prefetch" href="/assets/js/62.faedf14e.js"><link rel="prefetch" href="/assets/js/63.ce821da4.js"><link rel="prefetch" href="/assets/js/64.d3bd4444.js"><link rel="prefetch" href="/assets/js/65.6dce8124.js"><link rel="prefetch" href="/assets/js/66.9926dcf1.js"><link rel="prefetch" href="/assets/js/67.8ba47f6f.js"><link rel="prefetch" href="/assets/js/68.fb08fa45.js"><link rel="prefetch" href="/assets/js/69.99366761.js"><link rel="prefetch" href="/assets/js/7.65a53a16.js"><link rel="prefetch" href="/assets/js/70.b58184ca.js"><link rel="prefetch" href="/assets/js/71.e807ce86.js"><link rel="prefetch" href="/assets/js/72.fd85a201.js"><link rel="prefetch" href="/assets/js/73.347f4455.js"><link rel="prefetch" href="/assets/js/74.1614468f.js"><link rel="prefetch" href="/assets/js/75.1b48dd21.js"><link rel="prefetch" href="/assets/js/76.34386640.js"><link rel="prefetch" href="/assets/js/77.98723d2f.js"><link rel="prefetch" href="/assets/js/78.853e0232.js"><link rel="prefetch" href="/assets/js/79.f13b56d9.js"><link rel="prefetch" href="/assets/js/8.1f5a2468.js"><link rel="prefetch" href="/assets/js/80.9b7ea6e5.js"><link rel="prefetch" href="/assets/js/81.b6c297c9.js"><link rel="prefetch" href="/assets/js/82.0f97cc22.js"><link rel="prefetch" href="/assets/js/83.31634315.js"><link rel="prefetch" href="/assets/js/84.c8e9154d.js"><link rel="prefetch" href="/assets/js/85.961b5b48.js"><link rel="prefetch" href="/assets/js/86.0656beb0.js"><link rel="prefetch" href="/assets/js/87.2216b902.js"><link rel="prefetch" href="/assets/js/88.5f59eb52.js"><link rel="prefetch" href="/assets/js/89.c1a19999.js"><link rel="prefetch" href="/assets/js/9.4ab6239e.js"><link rel="prefetch" href="/assets/js/90.c3ffff3a.js"><link rel="prefetch" href="/assets/js/91.093bc4a1.js"><link rel="prefetch" href="/assets/js/92.b98a6c4b.js"><link rel="prefetch" href="/assets/js/93.721ce10b.js"><link rel="prefetch" href="/assets/js/94.2c601c95.js"><link rel="prefetch" href="/assets/js/95.d1677f3d.js"><link rel="prefetch" href="/assets/js/96.e71019bc.js"><link rel="prefetch" href="/assets/js/97.d7a92048.js"><link rel="prefetch" href="/assets/js/98.21bdf582.js"><link rel="prefetch" href="/assets/js/99.5df4fe80.js">
    <link rel="stylesheet" href="/assets/css/0.styles.a0ada997.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><h3 id="mysql-锁"><a href="#mysql-锁" aria-hidden="true" class="header-anchor">#</a> Mysql 锁</h3> <ul><li>对表进行加锁,已只读的方法创建锁</li> <li>特点： 如果是读锁，在同个session中对表进行修改会<strong>报错</strong>，</li> <li>如果在不同的session中对表加了读锁的表进行修改操作，不会报错，而是<strong>等待</strong></li></ul> <div class="language-sh extra-class"><pre class="language-sh"><code>lock table tableName READ
</code></pre></div><h3 id="acid"><a href="#acid" aria-hidden="true" class="header-anchor">#</a> ACID</h3> <ul><li>原子性：undo log (mvcc)</li> <li>一致性：最核心和最本质的要求</li> <li>隔离性：锁,mvcc</li> <li>持久性：redo log</li></ul> <h3 id="mvcc"><a href="#mvcc" aria-hidden="true" class="header-anchor">#</a> MVCC</h3> <ul><li><p>1.多版本并发控制</p></li> <li><p>2.当前读</p></li> <li><p>四个 隔离级别 通过 mvcc 和锁实现
1.READ-UNCOMMITTED</p></li></ul> <p>2.READ_COMMITTED</p> <p>3.REPEATABLE-READ</p> <p>4.SERIALIZABLE</p> <h4 id="实现原理"><a href="#实现原理" aria-hidden="true" class="header-anchor">#</a> 实现原理</h4> <p>1.三个隐藏字段</p> <ul><li>DB_TRX_ID  最近修改事务id</li> <li>DB_ROLL_PTR 回滚指针</li> <li>DB_ROW_ID  隐藏的主键</li></ul> <p>2.undo log</p> <p>3.read view
三个全局属性</p> <ul><li>1)trx_list 一个数值列表 用来维护read view 生成时刻正在活跃的事务id</li> <li>2)up_limit_id 记录trx_list 列表中 事务最小的id</li> <li>3)low_limit_id read view 生成时刻 系统尚未分配的下一个事务id</li></ul> <h3 id="查询innodb-锁的问题"><a href="#查询innodb-锁的问题" aria-hidden="true" class="header-anchor">#</a> 查询innodb 锁的问题</h3> <ul><li>锁类型：
共享锁 排他锁 意向锁（表锁） 记录锁（行锁） 间隙锁  临键锁 自增锁</li> <li>开启innodb_lock_output;</li> <li>查看死锁日志 show engine innodb status；</li></ul> <h3 id="幻读"><a href="#幻读" aria-hidden="true" class="header-anchor">#</a> 幻读</h3> <ul><li>当前读和快照读冲突</li> <li>事务A按照一定条件进行数据读取,期间事务B插入了相同搜索条件读新数据，事务A在按照原先条件进行读取发现了事务B未提交的数据</li> <li>临键锁</li></ul> <h3 id="数据库索引"><a href="#数据库索引" aria-hidden="true" class="header-anchor">#</a> 数据库索引</h3> <h4 id="io-读取次数少-分块读取-磁盘预读"><a href="#io-读取次数少-分块读取-磁盘预读" aria-hidden="true" class="header-anchor">#</a> IO 读取次数少 分块读取 磁盘预读</h4> <ul><li>磁盘和内存 交互用页 然后</li> <li>二叉树的 每个节点有两个分支就会有很深</li> <li>变成多叉树还有序 B树  数据和key放在一起 然后存储空间大 树分支范围就小 就会变深</li> <li>所以用B+树 B+树 叶子结点有指针 并且叶子结点存数据</li></ul> <h4 id="数据结构-b-树-二叉树-avl树-红黑树-b树"><a href="#数据结构-b-树-二叉树-avl树-红黑树-b树" aria-hidden="true" class="header-anchor">#</a> 数据结构 B+树 二叉树 AVL树  红黑树 B树</h4> <h3 id="索引"><a href="#索引" aria-hidden="true" class="header-anchor">#</a> 索引</h3> <h4 id="优化"><a href="#优化" aria-hidden="true" class="header-anchor">#</a> 优化</h4> <p>1.最左匹配原则
2.索引不要计算
3.is null 和is not null 不要用
4.不要用or操作符
5.不要类型转换
6.关联字段的长度 编码要一样
7.如果全表扫描比使用索引快也会失效</p> <h5 id="索引下推"><a href="#索引下推" aria-hidden="true" class="header-anchor">#</a> 索引下推</h5> <p>当进行索引查询时，首先根据索引来查找记录，然后再根据where条件来过滤记录</p> <h4 id="explain"><a href="#explain" aria-hidden="true" class="header-anchor">#</a> explain</h4> <p>1.id  执行顺序 越大执行越早</p> <p>2.select_type  没什么用</p> <p>3.table  查什么表</p> <p>4.partitions</p> <p>5.type  访问类型 重要 效率最低是all 最高是system 保证在range以上</p> <p>6.possible_keys  可能用到的索引</p> <p>7.key  所用的索引</p> <p>8.key_len  索引使用的字节数</p> <p>9.ref  索引被哪一列使用了</p> <p>10.rows 预估使用的行数</p> <p>11.extra 包含额外的信息</p> <h3 id="分库分表"><a href="#分库分表" aria-hidden="true" class="header-anchor">#</a> 分库分表</h3> <h4 id="分表模式"><a href="#分表模式" aria-hidden="true" class="header-anchor">#</a> 分表模式</h4> <p>1.水平分表
拆数据 按照范围分
2.垂直分表
拆字段 哪些字段常用，哪些不常用</p> <h3 id="分库分表原则"><a href="#分库分表原则" aria-hidden="true" class="header-anchor">#</a> 分库分表原则</h3> <p>1.能不切分尽量不要切分
2.如果一定要切分选择合适的切分规则，提前规划好
3.数据切分尽量通过数据冗余或者表分组来降低跨库join的可能
4.由于中间件对于数据的join实现的优劣难以把握,尽量少使用多表join</p> <h3 id="描述一下innodb和myisam的区别？"><a href="#描述一下innodb和myisam的区别？" aria-hidden="true" class="header-anchor">#</a> 描述一下InnoDB和MyISAM的区别？</h3> <table><thead><tr><th>区别</th> <th>Innodb</th> <th>MyISAM</th></tr></thead> <tbody><tr><td>事务</td> <td>支持</td> <td>不支持</td></tr> <tr><td>外键</td> <td>支持</td> <td>不支持</td></tr> <tr><td>索引</td> <td>即支持聚簇索引又支持非聚簇索引</td> <td>只支持非聚簇索引</td></tr> <tr><td>行锁</td> <td>支持</td> <td>不支持</td></tr> <tr><td>表锁</td> <td>支持</td> <td>支持</td></tr> <tr><td>存储文件</td> <td>frm，ibd</td> <td>frm,myi,myd</td></tr> <tr><td>具体行数</td> <td>每次必须要全表扫描统计行数</td> <td>通过变量保存行数</td></tr></tbody></table> <p>如何选择？</p> <p>​		1、是否需要支持事务，如果需要选择innodb，如果不需要选择myisam</p> <p>​		2、如果表的大部分请求都是读请求，可以考虑myisam，如果既有读也有写，使用innodb</p> <p>​		现在mysql的默认存储引擎已经变成了Innodb,推荐使用innodb</p> <h3 id="主从复制"><a href="#主从复制" aria-hidden="true" class="header-anchor">#</a> 主从复制</h3> <h5 id="原理："><a href="#原理：" aria-hidden="true" class="header-anchor">#</a> 原理：</h5> <p>​		（1）master服务器将数据的改变记录二进制binlog日志，当master上的数据发生改变时，则将其改变写入二进制日志中；</p> <p>​		（2）slave服务器会在一定时间间隔内对master二进制日志进行探测其是否发生改变，如果发生改变，则开始一个I/OThread请求master二进制事件</p> <p>​		（3）同时主节点为每个I/O线程启动一个dump线程，用于向其发送二进制事件，并保存至从节点本地的中继日志中，从节点将启动SQL线程从中继日志中读取二进制日志，在本地重放，使得其数据和主节点的保持一致，最后I/OThread和SQLThread将进入睡眠状态，等待下一次被唤醒。</p> <h5 id="也就是说："><a href="#也就是说：" aria-hidden="true" class="header-anchor">#</a> 也就是说：</h5> <ul><li>从库会生成两个线程,一个I/O线程,一个SQL线程;</li> <li>I/O线程会去请求主库的binlog,并将得到的binlog写到本地的relay-log(中继日志)文件中;</li> <li>主库会生成一个log dump线程,用来给从库I/O线程传binlog;</li> <li>SQL线程,会读取relay log文件中的日志,并解析成sql语句逐一执行;</li></ul> <h5 id="注意："><a href="#注意：" aria-hidden="true" class="header-anchor">#</a> 注意：</h5> <p>1--master将操作语句记录到binlog日志中，然后授予slave远程连接的权限（master一定要开启binlog二进制日志功能；通常为了数据安全考虑，slave也开启binlog功能）。</p> <p>2--slave开启两个线程：IO线程和SQL线程。其中：IO线程负责读取master的binlog内容到中继日志relay log里；SQL线程负责从relay log日志里读出binlog内容，并更新到slave的数据库里，这样就能保证slave数据和master数据保持一致了。</p> <p>3--Mysql复制至少需要两个Mysql的服务，当然Mysql服务可以分布在不同的服务器上，也可以在一台服务器上启动多个服务。</p> <p>4--Mysql复制最好确保master和slave服务器上的Mysql版本相同（如果不能满足版本一致，那么要保证master主节点的版本低于slave从节点的版本）</p> <p>5--master和slave两节点间时间需同步</p> <p>###主从配置</p> <h4 id="一主一从"><a href="#一主一从" aria-hidden="true" class="header-anchor">#</a> 一主一从</h4> <h5 id="主"><a href="#主" aria-hidden="true" class="header-anchor">#</a> 主:</h5> <h6 id="修改配置文件，执行以下命令打开mysql配置文件"><a href="#修改配置文件，执行以下命令打开mysql配置文件" aria-hidden="true" class="header-anchor">#</a> 修改配置文件，执行以下命令打开mysql配置文件</h6> <p>vi /etc/my.cnf</p> <h6 id="在mysqld模块中添加如下配置信息"><a href="#在mysqld模块中添加如下配置信息" aria-hidden="true" class="header-anchor">#</a> 在mysqld模块中添加如下配置信息</h6> <p>log-bin=master-bin #二进制文件名称</p> <p>binlog-format=ROW  #二进制日志格式，有row、statement、mixed三种格式，row指的是把改变的内容复制过去，而不是把命令在从服务器上执行一遍，statement指的是在主服务器上执行的SQL语句，在从服务器上执行同样的语句。MySQL默认采用基于语句的复制，效率比较高。mixed指的是默认采用基于语句的复制，一旦发现基于语句的无法精确的复制时，就会采用基于行的复制。</p> <p>server-id=1		   #要求各个服务器的id必须不一样</p> <p>binlog-do-db=msb   #同步的数据库名称</p> <h3 id="mysql主从同步延时分析"><a href="#mysql主从同步延时分析" aria-hidden="true" class="header-anchor">#</a> mysql主从同步延时分析</h3> <p>​		mysql的主从复制都是单线程的操作，主库对所有DDL和DML产生的日志写进binlog，由于binlog是顺序写，所以效率很高，slave的sql thread线程将主库的DDL和DML操作事件在slave中重放。DML和DDL的IO操作是随机的，不是顺序，所以成本要高很多，另一方面，由于sql thread也是单线程的，当主库的并发较高时，产生的DML数量超过slave的SQL thread所能处理的速度，或者当slave中有大型query语句产生了锁等待，那么延时就产生了。</p> <p>​		解决方案：</p> <p>​		1.业务的持久化层的实现采用分库架构，mysql服务可平行扩展，分散压力。</p> <p>​		2.单个库读写分离，一主多从，主写从读，分散压力。这样从库压力比主库高，保护主库。</p> <p>​		3.服务的基础架构在业务和mysql之间加入memcache或者redis的cache层。降低mysql的读压力。</p> <p>​		4.不同业务的mysql物理上放在不同机器，分散压力。</p> <p>​		5.使用比主库更好的硬件设备作为slave，mysql压力小，延迟自然会变小。</p> <p>​		6.使用更加强劲的硬件设备</p> <p>**mysql5.7之后使用MTS并行复制技术，永久解决复制延时问题</p> <h4 id="半同步复制"><a href="#半同步复制" aria-hidden="true" class="header-anchor">#</a> 半同步复制</h4> <p>事物在主库执行完binlog后接受到从库的ACK，才会回复客户端。所以，相比而言，性能有所降低</p> <p>1.确保事务提交后binlog至少传输到一个从库</p> <p>2.不保证从库应用完成这个事务的binlog</p> <p>3.网络异常或从库宕机，卡主库，直到超时或从库恢复</p> <h1 id="mysql的主从复制延迟问题"><a href="#mysql的主从复制延迟问题" aria-hidden="true" class="header-anchor">#</a> mysql的主从复制延迟问题</h1> <h2 id="mysql-主从同步"><a href="#mysql-主从同步" aria-hidden="true" class="header-anchor">#</a> mysql 主从同步</h2> <pre><code> 主数据库写入binary log （bin log）
 从库 IO Thread 去读 然后 写入relay log 
 从库 SQL Thread 去读 然后执行sql 持久化
</code></pre> <h3 id="_1、如何查看同步延迟状态？"><a href="#_1、如何查看同步延迟状态？" aria-hidden="true" class="header-anchor">#</a> 1、如何查看同步延迟状态？</h3> <pre><code> ​	在从服务器上通过  show slave status 查看具体的参数，有几个参数比较重要：
 
 ​	**master_log_file:	slave中的IO线程正在读取的主服务器二进制日志文件的名称**
 
 ​	**read_master_log_pos:	在当前的主服务器二进制日志中，slave中的IO线程已经读取的位置**
 
 ​	**relay_log_file:	sql线程当前正在读取和执行的中继日志文件的名称**
 
 ​	**relay_log_pos:	在当前的中继日志中，sql线程已经读取和执行的位置**
 
 ​	**relay_master_log_file:	由sql线程执行的包含多数近期事件的主服务器二进制日志文件的名称**
 
 ​	**slave_io_running:	IO线程是否被启动并成功的连接到主服务器上**
 
    **slave_sql_running:	sql线程是否被启动**
 
    **seconds_behind_master:	从属服务器sql线程和从属服务器IO线程之间的事件差距，单位以秒计**
</code></pre> <h3 id="_2、主从复制延迟产生的原因有哪些？"><a href="#_2、主从复制延迟产生的原因有哪些？" aria-hidden="true" class="header-anchor">#</a> 2、主从复制延迟产生的原因有哪些？</h3> <p>​		1、在某些部署环境中，备库所在的机器性能要比主库所在的机器性能差。此时如果机器的资源不足的话就会影响备库同步的效率；</p> <p>​		2、备库充当了读库，一般情况下主要写的压力在于主库，那么备库会提供一部分读的压力，而如果备库的查询压力过大的话，备库的查询消耗了大量的CPU资源，那么必不可少的就会影响同步的速度</p> <p>​		3、大事务执行，如果主库的一个事务执行了10分钟，而binlog的写入必须要等待事务完成之后，才会传入备库，那么此时在开始执行的时候就已经延迟了10分钟了</p> <p>​		4、主库的写操作是顺序写binlog，从库单线程去主库顺序读binlog，从库取到binlog之后在本地执行。mysql的主从复制都是<strong>单线程</strong>的操作，但是由于主库是顺序写，所以效率很高，而从库也是顺序读取主库的日志，此时的效率也是比较高的，但是当数据拉取回来之后变成了随机的操作，而不是顺序的，所以此时成本会提高。</p> <p>​		5、 从库在同步数据的同时，可能跟其他查询的线程发生锁抢占的情况，此时也会发生延时。</p> <p>​		6、 当主库的TPS并发非常高的时候，产生的DDL数量超过了一个线程所能承受的范围的时候，那么也可能带来延迟</p> <p>​		7、 在进行binlog日志传输的时候，如果网络带宽也不是很好，那么网络延迟也可能造成数据同步延迟</p> <p>​		这些就是可能会造成备库延迟的原因</p> <h3 id="_3、如何解决复制延迟的问题"><a href="#_3、如何解决复制延迟的问题" aria-hidden="true" class="header-anchor">#</a> 3、如何解决复制延迟的问题</h3> <p>​		先说一些虚的东西，什么叫虚的东西呢？就是一听上去感觉很有道理，但是在实施或者实际的业务场景中可能难度很大或者很难实现，下面我们从几个方面来进行描述：</p> <h4 id="_1、架构方面"><a href="#_1、架构方面" aria-hidden="true" class="header-anchor">#</a> 1、架构方面</h4> <p>​			1、业务的持久化层的实现采用分库架构，让不同的业务请求分散到不同的数据库服务上，分散单台机器的压力</p> <p>​			2、服务的基础架构在业务和mysql之间加入缓存层，减少mysql的读的压力，但是需要注意的是，如果数据经常要发生修改，那么这种设计是不合理的，因为需要频繁的去更新缓存中的数据，保持数据的一致性，导致缓存的命中率很低，所以此时就要慎用缓存了</p> <p>​			3、使用更好的硬件设备，比如cpu，ssd等，但是这种方案一般对于公司而言不太能接受，原因也很简单，会增加公司的成本，而一般公司其实都很抠门，所以意义也不大，但是你要知道这也是解决问题的一个方法，只不过你需要评估的是投入产出比而已。</p> <h4 id="_2、从库配置方面"><a href="#_2、从库配置方面" aria-hidden="true" class="header-anchor">#</a> 2、从库配置方面</h4> <p>​		<strong>1、修改sync_binlog的参数的值</strong></p> <p>​		想要合理设置此参数的值必须要清楚的知道binlog的写盘的流程：</p> <p>​		<img src="/img/mysql/sync_binlog.png" alt=""></p> <p>​		可以看到，每个线程有自己的binlog cache，但是共用同一份binlog。</p> <p>​		图中的write，指的就是把日志写入到文件系统的page cache，并没有把数据持久化到磁盘，所以速度快</p> <p>​		图中的fsync，才是将数据持久化到磁盘的操作。一般情况下，我们认为fsync才占用磁盘的IOPS</p> <p>​		而write和fsync的时机就是由参数sync_binlog来进行控制的。</p> <p>​		1、当sync_binlog=0的时候，表示每次提交事务都只write，不fsync</p> <p>​		2、当sync_binlog=1的时候，表示每次提交事务都执行fsync</p> <p>​		3、当sync_binlog=N的时候，表示每次提交事务都write，但积累N个事务后才fsync。</p> <p>​		一般在公司的大部分应用场景中，我们建议将此参数的值设置为1，因为这样的话能够保证数据的安全性，但是如果出现主从复制的延迟问题，可以考虑将此值设置为100~1000中的某个数值，非常不建议设置为0，因为设置为0的时候没有办法控制丢失日志的数据量，但是如果是对安全性要求比较高的业务系统，这个参数产生的意义就不是那么大了。</p> <p>​		2、直接禁用salve上的binlog，当从库的数据在做同步的时候，有可能从库的binlog也会进行记录，此时的话肯定也会消耗io的资源，因此可以考虑将其关闭，但是需要注意，如果你搭建的集群是级联的模式的话，那么此时的binlog也会发送到另外一台从库里方便进行数据同步，此时的话，这个配置项也不会起到太大的作用。</p> <p>​		3、设置innodb_flush_log_at_trx_commit 属性，这个属性在我讲日志的时候讲过，用来表示每一次的事务提交是否需要把日志都写入磁盘，这是很浪费时间的，一共有三个属性值，分别是0（每次写到服务缓存，一秒钟刷写一次），1（每次事务提交都刷写一次磁盘），2（每次写到os缓存，一秒钟刷写一次），一般情况下我们推荐设置成2，这样就算mysql的服务宕机了，卸载os缓存中的数据也会进行持久化。</p> <h3 id="_4、从根本上解决主从复制的延迟问题"><a href="#_4、从根本上解决主从复制的延迟问题" aria-hidden="true" class="header-anchor">#</a> 4、从根本上解决主从复制的延迟问题</h3> <p>​		很多同学在自己线上的业务系统中都使用了mysql的主从复制，但是大家需要注意的是，并不是所有的场景都适合主从复制，一般情况下是读要远远多于写的应用，同时读的时效性要求不那么高的场景。如果真实场景中真的要求立马读取到更新之后的数据，那么就只能强制读取主库的数据，所以在进行实现的时候要考虑实际的应用场景，不要为了技术而技术，这是很严重的事情。</p> <p>​		在mysql5.6版本之后引入了一个概念，就是我们通常说的并行复制，如下图：</p> <p><img src="/img/mysql/%E5%B9%B6%E8%A1%8C%E5%A4%8D%E5%88%B6.png" alt="image-20200715210204654"></p> <p>​		通过上图我们可以发现其实所谓的并行复制，就是在中间添加了一个分发的环节，也就是说原来的sql_thread变成了现在的coordinator组件，当日志来了之后，coordinator负责读取日志信息以及分发事务，真正的日志执行的过程是放在了worker线程上，由多个线程并行的去执行。</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token comment">-- 查看并行的slave的线程的个数，默认是0.表示单线程</span>
<span class="token keyword">show</span> <span class="token keyword">global</span> variables <span class="token operator">like</span> <span class="token string">'slave_parallel_workers'</span><span class="token punctuation">;</span>
<span class="token comment">-- 根据实际情况保证开启多少线程</span>
<span class="token keyword">set</span> <span class="token keyword">global</span> slave_parallel_workers <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
<span class="token comment">-- 设置并发复制的方式，默认是一个线程处理一个库，值为database</span>
<span class="token keyword">show</span> <span class="token keyword">global</span> variables <span class="token operator">like</span> <span class="token string">'%slave_parallel_type%'</span><span class="token punctuation">;</span>
<span class="token comment">-- 停止slave</span>
stop slave<span class="token punctuation">;</span>
<span class="token comment">-- 设置属性值</span>
<span class="token keyword">set</span> <span class="token keyword">global</span> slave_parallel_type<span class="token operator">=</span><span class="token string">'logical_check'</span><span class="token punctuation">;</span>
<span class="token comment">-- 开启slave</span>
<span class="token keyword">start</span> slave
<span class="token comment">-- 查看线程数</span>
<span class="token keyword">show</span> <span class="token keyword">full</span> processlist<span class="token punctuation">;</span>
</code></pre></div><p>​		通过上述的配置可以完成我们说的并行复制，但是此时你需要思考几个问题</p> <p>​		1、在并行操作的时候，可能会有并发的事务问题，我们的备库在执行的时候可以按照轮训的方式发送给各个worker吗？</p> <p>​		答案是不行的，因为事务被分发给worker以后，不同的worker就开始独立执行了，但是，由于CPU的不同调度策略，很可能第二个事务最终比第一个事务先执行，而如果刚刚好他们修改的是同一行数据，那么因为执行顺序的问题，可能导致主备的数据不一致。</p> <p>​		2、同一个事务的多个更新语句，能不能分给不同的worker来执行呢？</p> <p>​		答案是也不行，举个例子，一个事务更新了表t1和表t2中的各一行，如果这两条更新语句被分到不同worker的话，虽然最终的结果是主备一致的，但如果表t1执行完成的瞬间，备库上有一个查询，就会看到这个事务更新了一半的结果，破坏了事务逻辑的隔离性。</p> <p>​		我们通过讲解上述两个问题的最主要目的是为了说明一件事，就是coordinator在进行分发的时候，需要遵循的策略是什么？</p> <p>​		1、不能造成更新覆盖。这就要求更新同一行的两个事务，必须被分发到同一个worker中。</p> <p>​		2、同一个事务不能被拆开，必须放到同一个worker中。</p> <p>​		听完上面的描述，我们来说一下具体实现的原理和过程。</p> <p>​		如果让我们自己来设计的话，我们应该如何操作呢？这是一个值得思考的问题。其实如果按照实际的操作的话，我们可以按照粒度进行分类，分为按库分发，按表分发，按行分发。</p> <p>​		其实不管按照什么方式进行分发，大家需要注意的就是在分发的时候必须要满足我们上面说的两条规则，所以当我们进行分发的时候要在每一个worker上定义一个hash表，用来保存当前这个work正在执行的事务所涉及到的表。hash表的key值按照不同的粒度需要存储不同的值：</p> <p>​		按库分发：key值是数据库的名字，这个比较简单</p> <p>​		按表分发：key值是库名+表名</p> <p>​		按行分发：key值是库名+表名+唯一键</p> <h4 id="_1、mysql5-6版本的并行复制策略"><a href="#_1、mysql5-6版本的并行复制策略" aria-hidden="true" class="header-anchor">#</a> 1、MySQL5.6版本的并行复制策略</h4> <p>​		其实从mysql的5.6版本开始就已经支持了并行复制，只是支持的粒度是按库并行，这也是为什么现在的版本中可以选择类型为database，其实说的就是支持按照库进行并行复制。</p> <p>​		但是其实用过的同学应该都知道，这个策略的并行效果，取决于压力模型。如果在主库上有多个DB，并且各个DB的压力均衡，使用这个策略的效果会很好，但是如果主库的所有表都放在同一DB上，那么所有的操作都会分发给一个worker，变成单线程操作了，那么这个策略的效果就不好了，因此在实际的生产环境中，用的并不是特别多。</p> <h4 id="_2、mariadb的并行复制策略"><a href="#_2、mariadb的并行复制策略" aria-hidden="true" class="header-anchor">#</a> 2、mariaDB的并行复制策略</h4> <p>​		在mysql5.7的时候采用的是基于组提交的并行复制，换句话说，slave服务器的回放与主机是一致的，即主库是如何并行执行的那么slave就如何怎样进行并行回放，这点其实是参考了mariaDB的并行复制，下面我们来看下其实现原理。</p> <p>​		mariaDB的并行复制策略利用的就是这个特性：</p> <p>​		1、能够在同一组里提交的事务，一定不会修改同一行；</p> <p>​		2、主库上可以并行执行的事务，备库上也一定是可以并行执行的。</p> <p>​		在实现上，mariaDB是这么做的：</p> <p>​		1、在一组里面一起提交的事务，有一个相同的commit_id,下一组就是commit_id+1;</p> <p>​		2、commit_id直接写到binlog里面；</p> <p>​		3、传到备库应用的时候，相同commit_id的事务会分发到多个worker执行；</p> <p>​		4、这一组全部执行完成后，coordinator再去取下一批。</p> <p>​		这是mariaDB的并行复制策略，大体上看起来是没有问题的，但是你仔细观察的话会发现他并没有实现“真正的模拟主库并发度”这个目标，在主库上，一组事务在commit的时候，下一组事务是同时处于“执行中”状态的。</p> <p>​		我们真正想要达到的并行复制应该是如下的状态，也就是说当第一组事务提交的是，下一组事务是运行的状态，当第一组事务提交完成之后，下一组事务会立刻变成commit状态。</p> <p><img src="/img/mysql/mariaDB1.png" alt="img"></p> <p>​		但是按照mariaDB的并行复制策略，那么备库上的执行状态会变成如下所示：</p> <p><img src="/img/mysql/mariaDB2.png" alt="img"></p> <p>​		可以看到，这张图跟上面这张图的最大区别在于，备库上执行的时候必须要等第一组事务执行完成之后，第二组事务才能开始执行，这样系统的吞吐量就不够了。而且这个方案很容易被大事务拖后腿，如果trx2是一个大事务，那么在备库应用的时候，trx1和trx3执行完成之后，就只能等trx2完全执行完成，下一组才能开始执行，这段时间，只有一个worker线程在工作，是对资源的浪费。</p> <h4 id="_3、mysql5-7的并行复制策略"><a href="#_3、mysql5-7的并行复制策略" aria-hidden="true" class="header-anchor">#</a> 3、mysql5.7的并行复制策略</h4> <p>​		mysql5.7版本的时候，根据mariaDB的并行复制策略，做了相应的优化调整后，提供了自己的并行复制策略，并且可以通过参数slave-parallel-type来控制并行复制的策略：</p> <p>​		1、当配置的值为DATABASE的时候，表示使用5.6版本的按库并行策略；</p> <p>​		2、当配置的值为LOGICAL_CLOCK的时候，表示跟mariaDB相同的策略。</p> <p>​		此时，大家需要思考一个问题：<strong>同时处于执行状态的所有事务，是否可以并行？</strong></p> <p>​		答案是不行的，因为多个执行中的事务是有可能出现锁冲突的，锁冲突之后就会产生锁等待问题。</p> <p>​		在mariaDB中，所有处于commit状态的事务是可以并行，因为如果能commit的话就说明已经没有锁的问题，但是大家回想下，我们mysql的日志提交是两阶段提交，如下图，其实只要处于prepare状态就已经表示没有锁的问题了。</p> <p><img src="/img/mysql/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4.png" alt=""></p> <p>​		因此，mysql5.7的并行复制策略的思想是：</p> <p>​		1、同时处于prepare状态的事务，在备库执行是可以并行的。</p> <p>​		2、处于prepare状态的事务，与处于commit状态的事务之间，在备库上执行也是可以并行的。</p> <p>​		基于这样的处理机制，我们可以将大部分的日志处于prepare状态，因此可以设置</p> <p>​		1、binlog_group_commit_sync_delay 参数，表示延迟多少微秒后才调用 fsync;</p> <p>​		2、binlog_group_commit_sync_no_delay_count 参数，表示累积多少次以后才调用 fsync。</p> <h3 id="_5、基于gtid的主从复制问题"><a href="#_5、基于gtid的主从复制问题" aria-hidden="true" class="header-anchor">#</a> 5、基于GTID的主从复制问题</h3> <p>​		在我们之前讲解的主从复制实操中，每次想要复制，必须要在备机上执行对应的命令，如下所示：</p> <div class="language-sql extra-class"><pre class="language-sql"><code>change master <span class="token keyword">to</span> master_host<span class="token operator">=</span><span class="token string">'192.168.85.11'</span><span class="token punctuation">,</span>master_user<span class="token operator">=</span><span class="token string">'root'</span><span class="token punctuation">,</span>master_password<span class="token operator">=</span><span class="token string">'123456'</span><span class="token punctuation">,</span>master_port<span class="token operator">=</span><span class="token number">3306</span><span class="token punctuation">,</span>master_log_file<span class="token operator">=</span><span class="token string">'master-bin.000001'</span><span class="token punctuation">,</span>master_log_pos<span class="token operator">=</span><span class="token number">154</span><span class="token punctuation">;</span>
</code></pre></div><p>​		在此配置中我们必须要知道具体的binlog是哪个文件，同时在文件的哪个位置开始复制，正常情况下也没有问题，但是如果是一个主备主从集群，那么如果主机宕机，当从机开始工作的时候，那么备机就要同步从机的位置，此时位置可能跟主机的位置是不同的，因此在这种情况下，再去找位置就会比较麻烦，所以在5.6版本之后出来一个基于GTID的主从复制。</p> <p>​		GTID(global transaction id)是对于一个已提交事务的编号，并且是一个全局唯一的编号。GTID实际上是由UUID+TID组成的，其中UUID是mysql实例的唯一标识，TID表示该实例上已经提交的事务数量，并且随着事务提交单调递增。这种方式保证事务在集群中有唯一的ID，强化了主备一致及故障恢复能力。</p> <h4 id="_1、基于gtid的搭建"><a href="#_1、基于gtid的搭建" aria-hidden="true" class="header-anchor">#</a> 1、基于GTID的搭建</h4> <p>​		1、修改mysql配置文件，添加如下配置</p> <div class="language-sql extra-class"><pre class="language-sql"><code>gtid_mode<span class="token operator">=</span><span class="token keyword">on</span>
enforce<span class="token operator">-</span>gtid<span class="token operator">-</span>consistency<span class="token operator">=</span><span class="token boolean">true</span>
</code></pre></div><p>​		2、重启主从的服务</p> <p>​		3、从库执行如下命令</p> <div class="language-sql extra-class"><pre class="language-sql"><code>change master <span class="token keyword">to</span> master_host<span class="token operator">=</span><span class="token string">'192.168.85.111'</span><span class="token punctuation">,</span>master_user<span class="token operator">=</span><span class="token string">'root'</span><span class="token punctuation">,</span>master_password<span class="token operator">=</span><span class="token string">'123456'</span>
<span class="token punctuation">,</span>master_auto_position<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
</code></pre></div><p>​		4、主库从库插入数据测试。</p> <h3 id="_2、基于gtid的并行复制"><a href="#_2、基于gtid的并行复制" aria-hidden="true" class="header-anchor">#</a> 2、基于GTID的并行复制</h3> <p>​		无论是什么方式的主从复制其实原理相差都不是很大，关键点在于将组提交的信息存放在GTId中。</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">show</span> binlog events <span class="token operator">in</span> <span class="token string">'lian-bin.000001'</span><span class="token punctuation">;</span>
</code></pre></div><p><img src="/img/mysql/gtid.png" alt="image-20200724221610397"></p> <p>previous_gtids:用于表示上一个binlog最后一个gtid的位置，每个binlog只有一个。</p> <p>gtid:当开启gtid的时候，每一个操作语句执行前会添加一个gtid事件，记录当前全局事务id，组提交信息被保存在gtid事件中，有两个关键字段，last_committed,sequence_number用来标识组提交信息。</p> <p><img src="/img/mysql/gtid2.png" alt="image-20200724222034179"></p> <p>上述日志看起来可能比较麻烦，可以使用如下命令执行：</p> <p><img src="/img/mysql/gtid3.png" alt="image-20200724222128641"></p> <p>其中last_committed表示事务提交的时候，上次事务提交的编号，如果事务具有相同的last_committed值表示事务就在一个组内，在备库执行的时候可以并行执行。同时大家还要注意，每个last_committed的值都是上一个组事务的sequence_number值。</p> <p>看到此处，大家可能会有疑问，如果我们不开启gtid，分组信息该如何保存呢？</p> <p>其实是一样的，当没有开启的时候，数据库会有一个Anonymous_Gtid，用来保存组相关的信息。</p> <p>如果大家想看并行的效果的话，可以执行如下代码：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>mashibing</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>sql</span><span class="token punctuation">.</span><span class="token class-name">Connection</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>sql</span><span class="token punctuation">.</span><span class="token class-name">DriverManager</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>sql</span><span class="token punctuation">.</span><span class="token class-name">PreparedStatement</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>sql</span><span class="token punctuation">.</span><span class="token class-name">SQLException</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util</span><span class="token punctuation">.</span><span class="token class-name">Date</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConCurrentInsert</span>  <span class="token keyword">extends</span> <span class="token class-name">Thread</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">String</span> url <span class="token operator">=</span> <span class="token string">&quot;jdbc:mysql://192.168.85.111/lian2&quot;</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> name <span class="token operator">=</span> <span class="token string">&quot;com.mysql.jdbc.Driver&quot;</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> user <span class="token operator">=</span> <span class="token string">&quot;root&quot;</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> password <span class="token operator">=</span> <span class="token string">&quot;123456&quot;</span><span class="token punctuation">;</span>
        <span class="token class-name">Connection</span> conn <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
            conn <span class="token operator">=</span> <span class="token class-name">DriverManager</span><span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> user<span class="token punctuation">,</span> password<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取连接</span>
            conn<span class="token punctuation">.</span><span class="token function">setAutoCommit</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//关闭自动提交，不然conn.commit()运行到这句会报错</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e1<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e1<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 开始时间</span>
        <span class="token class-name">Long</span> begin <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// sql前缀</span>
        <span class="token class-name">String</span> prefix <span class="token operator">=</span> <span class="token string">&quot;INSERT INTO t1 (id,age) VALUES &quot;</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment">// 保存sql后缀</span>
            <span class="token class-name">StringBuffer</span> suffix <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 设置事务为非自动提交</span>
            conn<span class="token punctuation">.</span><span class="token function">setAutoCommit</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 比起st，pst会更好些</span>
            <span class="token class-name">PreparedStatement</span> pst <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">PreparedStatement</span><span class="token punctuation">)</span> conn<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//准备执行语句</span>
            <span class="token comment">// 外层循环，总提交事务次数</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                suffix <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 第j次提交步长</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> <span class="token number">10</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 构建SQL后缀</span>
                    suffix<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">&quot;(&quot;</span> <span class="token operator">+</span>i<span class="token operator">*</span>j<span class="token operator">+</span><span class="token string">&quot;,&quot;</span><span class="token operator">+</span>i<span class="token operator">*</span>j<span class="token operator">+</span><span class="token string">&quot;),&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token comment">// 构建完整SQL</span>
                <span class="token class-name">String</span> sql <span class="token operator">=</span> prefix <span class="token operator">+</span> suffix<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> suffix<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 添加执行SQL</span>
                pst<span class="token punctuation">.</span><span class="token function">addBatch</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 执行操作</span>
                pst<span class="token punctuation">.</span><span class="token function">executeBatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 提交事务</span>
                conn<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 清空上一次添加的数据</span>
                suffix <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 头等连接</span>
            pst<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            conn<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 结束时间</span>
        <span class="token class-name">Long</span> end <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 耗时</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;100万条数据插入花费时间 : &quot;</span> <span class="token operator">+</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> begin<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1000</span> <span class="token operator">+</span> <span class="token string">&quot; s&quot;</span><span class="token operator">+</span><span class="token string">&quot;  插入完成&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span><span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">new</span> <span class="token class-name">ConCurrentInsert</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><h3 id="bin-log的组提交"><a href="#bin-log的组提交" aria-hidden="true" class="header-anchor">#</a> bin log的组提交</h3> <p>​	  在之前的版本中，mysql的binlog是无法实现组提交的，原因在于redo log和binlog的刷盘串行化问题，</p> <pre><code>  而实现串行化的目的也是为了保证两份日志保持一致，而在5.6版本之后提供了一种解决方案，能够保证binlog实现组提交。
  
  
  基本思想是：引入队列机制保证 innodb commit顺序与binlog落盘顺序一致，并将事务分组，组内的binlog刷盘动作交给一个事务进行，实现组提交的目的。
  
  
  binlog提交将提交分为了3个阶段，flush阶段，sync阶段和commit阶段。每个阶段都有一个队列，每个队列有一个mutex保护，
  
  
  预定进入队列的第一个线程为leader，其他线程为follower，所有事情交给leader去做，leader做完所有的动作之后，通知follower刷盘结束</code></pre></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.a8d644b6.js" defer></script><script src="/assets/js/2.b0571e25.js" defer></script><script src="/assets/js/33.928e8282.js" defer></script>
  </body>
</html>
