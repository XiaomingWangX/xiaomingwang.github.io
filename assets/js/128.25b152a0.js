(window.webpackJsonp=window.webpackJsonp||[]).push([[128],{401:function(t,v,_){"use strict";_.r(v);var e=_(10),s=Object(e.a)({},function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"服务端"}},[t._v("服务端")]),t._v(" "),_("p",[_("img",{attrs:{src:"/img/network/socket_1.png",alt:"socket"}})]),t._v(" "),_("ul",[_("li",[t._v("启动的时候 (netstat查看)  LISTEN 状态")]),t._v(" "),_("li",[t._v("启动的时候 (lsof -p XXXX 查看) FD:5u 的监听状态")]),t._v(" "),_("li",[t._v("accept 之后开始分配")])]),t._v(" "),_("h3",{attrs:{id:"socket-两种状态"}},[t._v("SOCKET 两种状态")]),t._v(" "),_("ul",[_("li",[t._v("LISTEN-SOCKET 监听的socket\n就是server bind()+listen()")]),t._v(" "),_("li",[t._v("ESTABLISHED-SOCKET 已经完成连接的socket\nCLIENT:connect()\nSERVER:accept()")])]),t._v(" "),_("h3",{attrs:{id:"socket-queue"}},[t._v("socket queue")]),t._v(" "),_("ul",[_("li",[t._v("listen:")])]),t._v(" "),_("ul",[_("li",[t._v("send-queue:积压的没有发送完成的字节数 （数值（长度）backlog）")])]),t._v(" "),_("ul",[_("li",[t._v("可能丢数据")])]),t._v(" "),_("ul",[_("li",[t._v("receive-queue:积压的没有读取的字节书 （是accept队列）")])]),t._v(" "),_("h3",{attrs:{id:"丢数据"}},[t._v("丢数据")]),t._v(" "),_("h1",{attrs:{id:"客户端"}},[t._v("客户端")]),t._v(" "),_("ul",[_("li",[t._v("连接的时候即使服务端阻塞 ,三次握手也完成了 ESTABLISHED(netstat 完成了)")])]),t._v(" "),_("h3",{attrs:{id:"长连接"}},[t._v("长连接")]),t._v(" "),_("p",[t._v("连接→数据传输→保持连接(心跳)→数据传输→保持连接(心跳)→……→关闭连接；")]),t._v(" "),_("p",[t._v("这就要求长连接在没有数据通信时，定时发送数据包(心跳)，以维持连接状态，短连接在没有数据传输时直接关闭就行了")]),t._v(" "),_("h3",{attrs:{id:"短连接"}},[t._v("短连接")]),t._v(" "),_("p",[t._v("短连接是指通信双方有数据交互时，就建立一个TCP连接，数据发送完成后，则断开此TCP连接")]),t._v(" "),_("p",[t._v("比如http的，只是连接、请求、关闭，过程时间较短,服务器若是一段时间内没有收到请求即可关闭连接")]),t._v(" "),_("p",[t._v("通常的短连接操作步骤是： 连接→数据传输→关闭连接")])])},[],!1,null,null,null);v.default=s.exports}}]);