(window.webpackJsonp=window.webpackJsonp||[]).push([[124],{396:function(_,v,i){"use strict";i.r(v);var l=i(10),e=Object(l.a)({},function(){var _=this,v=_.$createElement,i=_._self._c||v;return i("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[i("h1",{attrs:{id:"操作系统io模型"}},[_._v("操作系统IO模型")]),_._v(" "),i("h2",{attrs:{id:"内核"}},[_._v("内核")]),_._v(" "),i("ul",[i("li",[_._v("kernel")]),_._v(" "),i("li",[_._v("VFS树 :\n虚拟文件系统 ,不同的节点（目录）映射到不同的物理位置")]),_._v(" "),i("li",[_._v("inode : id\n虚拟文件系统里面都有的唯一id\n— pageCache :4k大小 页缓存\n程序修改pageCache的时候 会标志dirty 需要flush（刷到磁盘）")]),_._v(" "),i("li",[_._v("fd")])]),_._v(" "),i("h2",{attrs:{id:"文件系统"}},[_._v("文件系统")]),_._v(" "),i("h3",{attrs:{id:"目录"}},[_._v("目录")]),_._v(" "),i("p",[_._v("df")]),_._v(" "),i("ul",[i("li",[_._v("/boot -> /dev/sda1 (1分区) 200M 引导 kernel img 在里面")]),_._v(" "),i("li",[_._v("/dev/shm -> tmpfs  (2分区)  2G")]),_._v(" "),i("li",[_._v("/      ->/dev/sda3 (3分区) 根目录  193G /boot 覆盖挂在 1分区")])]),_._v(" "),i("p",[_._v("加硬盘 /dev/sdb 可以挂载其他目录")]),_._v(" "),i("h3",{attrs:{id:"ll-开头名称"}},[_._v("ll 开头名称")]),_._v(" "),i("p",[_._v("例如 ：-rw-r--r--")]),_._v(" "),i("ul",[i("li",[_._v("-：普通文件")]),_._v(" "),i("li",[_._v("d：目录")]),_._v(" "),i("li",[_._v("l：连接")]),_._v(" "),i("li",[_._v("c：字符设备")]),_._v(" "),i("li",[_._v("s：socket")]),_._v(" "),i("li",[_._v("p：pipeline")])]),_._v(" "),i("h3",{attrs:{id:"ln-建立硬连接（引用）-ln-s-软连接"}},[_._v("ln 建立硬连接（引用）   ln -s 软连接")]),_._v(" "),i("h3",{attrs:{id:"任何程序都有"}},[_._v("任何程序都有")]),_._v(" "),i("ul",[i("li",[_._v("0.标准输入")]),_._v(" "),i("li",[_._v("1.标准输出")]),_._v(" "),i("li",[_._v("2.报错输出")])]),_._v(" "),i("p",[_._v("/proc/$$  $$是当前bash的pid")]),_._v(" "),i("p",[_._v("/proc/$$/fd 看当前bash开启的io")]),_._v(" "),i("p",[_._v("重定向:是一种机制")]),_._v(" "),i("h3",{attrs:{id:"java-file-和buffer区别"}},[_._v("java file 和buffer区别")]),_._v(" "),i("ul",[i("li",[_._v("file :执行的时候 file 一次写一行,然后一直会在用户态和内核态切换")]),_._v(" "),i("li",[_._v("buffer: 执行的时候单位传输的数据多,(8KB),减少系统调用")])]),_._v(" "),i("h3",{attrs:{id:"谈谈什么是零拷贝？"}},[_._v("谈谈什么是零拷贝？")]),_._v(" "),i("p",[_._v("零拷贝是指计算机执行IO操作时，CPU不需要将数据从一个存储区域复制到另一个存储区域，\n从而可以减少上下文切换以及CPU的拷贝时间。它是一种I/O操作优化技术。")]),_._v(" "),i("h4",{attrs:{id:"传统-io-的执行流程"}},[_._v("传统 IO 的执行流程")]),_._v(" "),i("p",[_._v("IO密集型肯定有用户态内核态切换过程，因为基于都是基于内核的read\n传统的IO流程，包括read和write的过程。")]),_._v(" "),i("ul",[i("li",[_._v("read：把数据从磁盘读取到内核缓冲区，再拷贝到用户缓冲区")]),_._v(" "),i("li",[_._v("write：先把数据写入到socket缓冲区，最后写入网卡设备。")])]),_._v(" "),i("p",[i("img",{attrs:{src:"/img/io/zero_copy1.png",alt:"normal_copy"}})]),_._v(" "),i("ul",[i("li",[_._v("用户应用进程调用read函数，向操作系统发起IO调用，上下文从用户态转为内核态（切换1）")]),_._v(" "),i("li",[_._v("DMA控制器把数据从磁盘中，读取到内核缓冲区。")]),_._v(" "),i("li",[_._v("CPU把内核缓冲区数据，拷贝到用户应用缓冲区，上下文从内核态转为用户态（切换2），read函数返回")]),_._v(" "),i("li",[_._v("用户应用进程通过write函数，发起IO调用，上下文从用户态转为内核态（切换3）")]),_._v(" "),i("li",[_._v("CPU将用户缓冲区中的数据，拷贝到socket缓冲区")]),_._v(" "),i("li",[_._v("DMA控制器把数据从socket缓冲区，拷贝到网卡设备，上下文从内核态切换回用户态（切换4），write函数返回")]),_._v(" "),i("li",[_._v("传统IO的读写流程，包括了4次上下文切换（4次用户态和内核态的切换），4次数据拷贝（两次CPU拷贝以及两次的DMA拷贝)。")])]),_._v(" "),i("h4",{attrs:{id:"零拷贝实现方式："}},[_._v("零拷贝实现方式：")]),_._v(" "),i("h5",{attrs:{id:"零拷贝并不是没有拷贝数据，而是减少用户态-内核态的切换次数以及cpu拷贝的次数。零拷贝一般有这三种实现方式："}},[_._v("零拷贝并不是没有拷贝数据，而是减少用户态/内核态的切换次数以及CPU拷贝的次数。零拷贝一般有这三种实现方式：")]),_._v(" "),i("ul",[i("li",[_._v("mmap+write")]),_._v(" "),i("li",[_._v("sendfile")]),_._v(" "),i("li",[_._v("带有DMA收集拷贝功能的sendfile")]),_._v(" "),i("li",[_._v("mmap+write")])]),_._v(" "),i("h6",{attrs:{id:"mmap就是用了虚拟内存这个特点，它将内核中的读缓冲区与用户空间的缓冲区进行映射，以减少数据拷贝次数！"}},[_._v("mmap就是用了虚拟内存这个特点，它将内核中的读缓冲区与用户空间的缓冲区进行映射，以减少数据拷贝次数！")]),_._v(" "),i("p",[i("img",{attrs:{src:"/img/io/zero_copy2.png",alt:"zero_copy"}})]),_._v(" "),i("ul",[i("li",[_._v("用户进程通过mmap方法向操作系统内核发起IO调用，上下文从用户态切换为内核态。")]),_._v(" "),i("li",[_._v("CPU利用DMA控制器，把数据从硬盘中拷贝到内核缓冲区。")]),_._v(" "),i("li",[_._v("上下文从内核态切换回用户态，mmap方法返回。")]),_._v(" "),i("li",[_._v("用户进程通过write方法向操作系统内核发起IO调用，上下文从用户态切换为内核态。")]),_._v(" "),i("li",[_._v("CPU将内核缓冲区的数据拷贝到的socket缓冲区。")]),_._v(" "),i("li",[_._v("CPU利用DMA控制器，把数据从socket缓冲区拷贝到网卡，上下文从内核态切换回用户态，write调用返回。")])]),_._v(" "),i("p",[_._v("mmap+write实现的零拷贝，I/O发生了4次用户空间与内核空间的上下文切换，以及3次数据拷贝（包括了2次DMA拷贝和1次CPU拷贝）。")]),_._v(" "),i("h6",{attrs:{id:"sendfile"}},[_._v("sendfile")]),_._v(" "),i("p",[_._v("sendfile表示在两个文件描述符之间传输数据，它是在操作系统内核中操作的，避免了数据从内核缓冲区和用户缓冲区之间的拷贝操作")]),_._v(" "),i("p",[i("img",{attrs:{src:"/img/io/zero_copy3.png",alt:"zero_copy"}})]),_._v(" "),i("ul",[i("li",[_._v("用户进程发起sendfile系统调用，上下文（切换1）从用户态转向内核态")]),_._v(" "),i("li",[_._v("DMA控制器，把数据从硬盘中拷贝到内核缓冲区。")]),_._v(" "),i("li",[_._v("CPU将读缓冲区中数据拷贝到socket缓冲区")]),_._v(" "),i("li",[_._v("DMA控制器，异步把数据从socket缓冲区拷贝到网卡，")]),_._v(" "),i("li",[_._v("上下文（切换2）从内核态切换回用户态，sendfile调用返回。")])]),_._v(" "),i("p",[_._v("sendfile实现的零拷贝，I/O发生了2次用户空间与内核空间的上下文切换，以及3次数据拷贝。其中3次数据拷贝中，包括了2次DMA拷贝和1次CPU拷贝。")]),_._v(" "),i("h6",{attrs:{id:"带有dma收集拷贝功能的sendfile"}},[_._v("带有DMA收集拷贝功能的sendfile")]),_._v(" "),i("p",[_._v("linux 2.4版本之后，对sendfile做了优化升级，引入SG-DMA技术，其实就是对DMA拷贝加入了scatter/gather操作，它可以直接从内核空间缓冲区中将数据读取到网卡。使用这个特点搞零拷贝，即还可以多省去一次CPU拷贝。")]),_._v(" "),i("p",[i("img",{attrs:{src:"/img/io/zero_copy4.png",alt:"zero_copy"}})]),_._v(" "),i("ul",[i("li",[_._v("用户进程发起sendfile系统调用，上下文（切换1）从用户态转向内核态")]),_._v(" "),i("li",[_._v("DMA控制器，把数据从硬盘中拷贝到内核缓冲区。")]),_._v(" "),i("li",[_._v("CPU把内核缓冲区中的文件描述符信息（包括内核缓冲区的内存地址和偏移量）发送到socket缓冲区")]),_._v(" "),i("li",[_._v("DMA控制器根据文件描述符信息，直接把数据从内核缓冲区拷贝到网卡")]),_._v(" "),i("li",[_._v("上下文（切换2）从内核态切换回用户态，sendfile调用返回。")]),_._v(" "),i("li",[_._v("可以发现，sendfile+DMA scatter/gather实现的零拷贝，I/O发生了2次用户空间与内核空间的上下文切换，以及2次数据拷贝。其中2次数据拷贝都是包DMA拷贝。这就是真正的 零拷贝（Zero-copy) 技术，全程都没有通过CPU来搬运数据，所有的数据都是通过DMA来进行传输的。")])])])},[],!1,null,null,null);v.default=e.exports}}]);