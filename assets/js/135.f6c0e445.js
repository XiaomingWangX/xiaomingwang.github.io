(window.webpackJsonp=window.webpackJsonp||[]).push([[135],{407:function(t,n,i){"use strict";i.r(n);var e=i(10),s=Object(e.a)({},function(){var t=this,n=t.$createElement,i=t._self._c||n;return i("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[i("h1",{attrs:{id:"启动流程-源码解析"}},[t._v("启动流程(源码解析)")]),t._v(" "),i("h2",{attrs:{id:"第一步new了一个springapplication对象-，第二部调用了run-方法。接下来我们一起看下new-springapplication-主要做了什么事情。"}},[t._v("第一步new了一个SpringApplication对象 ，第二部调用了run()方法。接下来我们一起看下new SpringApplication() 主要做了什么事情。")]),t._v(" "),i("h2",{attrs:{id:"new-springapplication对象"}},[t._v("new SpringApplication对象")]),t._v(" "),i("div",{staticClass:"language- line-numbers-mode"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[t._v('public SpringApplication(ResourceLoader resourceLoader, Class<?>... primarySources) {\n\t\tthis.resourceLoader = resourceLoader;\n\t\tAssert.notNull(primarySources, "PrimarySources must not be null");\n\t\t//1、先把主类保存起来\n\t\tthis.primarySources = new LinkedHashSet<>(Arrays.asList(primarySources));\n\t\t//2、判断运行项目的类型\n\t\tthis.webApplicationType = WebApplicationType.deduceFromClasspath();\n\t\t//3、扫描当前路径下META-INF/spring.factories文件的，加载ApplicationContextInitializer接口实例\n\t\tsetInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));\n\t\t//4、扫描当前路径下META-INF/spring.factories文件的，加载ApplicationListener接口实例\n\t\tsetListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));\n\t\tthis.mainApplicationClass = deduceMainApplicationClass();\n\t}\n')])]),t._v(" "),i("div",{staticClass:"line-numbers-wrapper"},[i("span",{staticClass:"line-number"},[t._v("1")]),i("br"),i("span",{staticClass:"line-number"},[t._v("2")]),i("br"),i("span",{staticClass:"line-number"},[t._v("3")]),i("br"),i("span",{staticClass:"line-number"},[t._v("4")]),i("br"),i("span",{staticClass:"line-number"},[t._v("5")]),i("br"),i("span",{staticClass:"line-number"},[t._v("6")]),i("br"),i("span",{staticClass:"line-number"},[t._v("7")]),i("br"),i("span",{staticClass:"line-number"},[t._v("8")]),i("br"),i("span",{staticClass:"line-number"},[t._v("9")]),i("br"),i("span",{staticClass:"line-number"},[t._v("10")]),i("br"),i("span",{staticClass:"line-number"},[t._v("11")]),i("br"),i("span",{staticClass:"line-number"},[t._v("12")]),i("br"),i("span",{staticClass:"line-number"},[t._v("13")]),i("br")])]),i("p",[t._v("利用SPI机制扫描 META-INF/spring.factories 这个文件，并且加载 ApplicationContextInitializer、ApplicationListener 接口实例。")]),t._v(" "),i("p",[t._v("1、ApplicationContextInitializer(MAP 包含各个ApplicationContextInitializer) 这个类当springboot上下文Context初始化完成后会调用")]),t._v(" "),i("p",[t._v("2、ApplicationListener (MAP 包含各个ApplicationListener) 当springboot启动时事件change后都会触发")]),t._v(" "),i("h3",{attrs:{id:"run-调用"}},[t._v("run()调用")]),t._v(" "),i("h4",{attrs:{id:"createapplicationcontext"}},[t._v("createApplicationContext()")]),t._v(" "),i("p",[t._v("Web类型项目创建上下文对象 AnnotationConfigServletWebServerApplicationContext 。")]),t._v(" "),i("p",[t._v("这里会把 ConfigurationClassPostProcessor 、AutowiredAnnotationBeanPostProcessor 等一些核心组件加入到Spring容器")]),t._v(" "),i("h4",{attrs:{id:"refreshcontext"}},[t._v("refreshContext()")]),t._v(" "),i("p",[t._v("spring的refresh 实现很多前置后置方法 启动Spring容器和内置的Servlet容器")])])},[],!1,null,null,null);n.default=s.exports}}]);