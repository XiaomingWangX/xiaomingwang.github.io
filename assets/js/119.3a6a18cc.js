(window.webpackJsonp=window.webpackJsonp||[]).push([[119],{392:function(e,t,r){"use strict";r.r(t);var n=r(10),i=Object(n.a)({},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("p",[e._v("#dubbo原理")]),e._v(" "),r("h2",{attrs:{id:"框架设计"}},[e._v("框架设计")]),e._v(" "),r("p",[e._v("dubbo框架整体分为3层，业务层、RPC层、远程通信层")]),e._v(" "),r("h3",{attrs:{id:"业务层"}},[e._v("业务层")]),e._v(" "),r("pre",[r("code",[e._v("对于开发者来说只是使用到业务层，写一个接口和一个实现，想要远程调用只需要调接口方法就行了\n")])]),e._v(" "),r("h3",{attrs:{id:"rpc层"}},[e._v("RPC层")]),e._v(" "),r("pre",[r("code",[e._v("RPC层分为Config层、Proxy层、Registry层、Cluster层、Monitor层、Protocol层\nConfig：配置层，封装配置文件配置的信息\nProxy：服务代理层，通过代理层生成客户端、服务端代理对象，通过代理对象来完成调用\nRegistry：注册中心层，服务提供者需要注册到注册中心，调用者需要从注册中心订阅需要的服务\nCluster：路由层，有可能一个服务在多台机器上都有，这一层可以做到负载均衡\nMonitor：监控中心层，每一次调用信息都会发给监控层，监控层收到数据就会在界面上展示监控数据\nProtocol：远程调用层，封装整个RPC调用。\n")])]),e._v(" "),r("h3",{attrs:{id:"远程通信层"}},[e._v("远程通信层")]),e._v(" "),r("pre",[r("code",[e._v("Exchange：信息交换层，创建一个客户端，一个服务端，两者架起管道进行数据传输\nTransport：传输层，真正传输数据的一层，Transport底层就是Netty框架\nSerial：序列化层，整个传输过程中发送数据需要序列化，接收数据需要进行反序列化\n")])]),e._v(" "),r("h3",{attrs:{id:"dubbo-长连接"}},[e._v("dubbo 长连接")]),e._v(" "),r("p",[e._v("Dubbo RPC使用dubbo协议只需要一个长连接就可以收发所有请求，为什么使用http协议的Spring Cloud即便使用长连接也需要连接池呢？")]),e._v(" "),r("p",[e._v("http协议是一种同步应答的交互模式的应用层协议。就是客户端向服务端建立连接后，向服务端发起请求时，\n客户端必须要阻塞当前连接等到服务端响应，即便使用NIO。")]),e._v(" "),r("p",[e._v("如果你用一个Chanel向服务端发送一个http请求，没等服务端响应，你又用Chanel向服务端发送另一个请求，\n那服务端响应的结果客户端就没办法知道对应是哪个请求的响应。因此客户端必须同步阻塞等待，除非客户端不需要响应结果。")]),e._v(" "),r("p",[e._v("dubbo协议、以及我们自定义的协议为什么可以只用一个长连接处理接收和发送所有请求？\n原因很简单，dubbo协议会为每个请求数据包设置一个不会重复的id，并且用一个Map存储id对应的Future，\n让发起调用的线程阻塞等待结果。服务端在响应数据包时，将请求id回写到数据包，客户端的单一长连接在接收到响应数据包时，\n根据请求id从Map中获取Future并写入值、将阻塞等待的发请调用的线程唤醒。")]),e._v(" "),r("h3",{attrs:{id:"keeplive："}},[e._v("keeplive：")]),e._v(" "),r("h4",{attrs:{id:"http"}},[e._v("http")]),e._v(" "),r("p",[e._v("header 里 Connection: Keep-Alive"),r("br"),e._v("\ntcp open---\x3erequest1---\x3eresponse1---\x3erequest2---\x3eresponse2...---\x3etcp close")]),e._v(" "),r("h4",{attrs:{id:"tcp-中的-keepalive-机制"}},[e._v("TCP 中的 KeepAlive 机制")]),e._v(" "),r("p",[e._v("KeepAlive 并不是 TCP 协议的一部分，但是大多数操作系统都实现了这个机制。KeepAlive 机制开启后，\n在一定时间内(一般时间为 7200s，参数 tcp_keepalive_time)在链路上没有数据传送的情况下，\nTCP 层将发送相应的KeepAlive探针以确定连接可用性，探测失败后重试 10(参数 tcp_keepalive_probes)次，\n每次间隔时间 75s(参数 tcp_keepalive_intvl)，所有探测失败后，才认为当前连接已经不可用")]),e._v(" "),r("h4",{attrs:{id:"在-netty-中开启-keepalive："}},[e._v("在 Netty 中开启 KeepAlive：")]),e._v(" "),r("pre",[r("code",[e._v("   bootstrap.option(ChannelOption.TCP_NODELAY, true)\n")])]),e._v(" "),r("h4",{attrs:{id:"linux-操作系统中设置-keepalive-相关参数，"}},[e._v("Linux 操作系统中设置 KeepAlive 相关参数，")]),e._v(" "),r("p",[e._v("修改 /etc/sysctl.conf 文件：")]),e._v(" "),r("p",[e._v("net.ipv4.tcp_keepalive_time=90")]),e._v(" "),r("p",[e._v("net.ipv4.tcp_keepalive_intvl=15")]),e._v(" "),r("p",[e._v("net.ipv4.tcp_keepalive_probes=2")]),e._v(" "),r("h4",{attrs:{id:"http-keep-alive"}},[e._v("http Keep-Alive")]),e._v(" "),r("p",[e._v("在下载某些站点的时候，看到返回的http头中，有明确的对长连接的timeout限制。")]),e._v(" "),r("p",[e._v("Keep-Alive: timeout=1, max=100")]),e._v(" "),r("p",[e._v("timeout：过期时间1秒（对应httpd.conf里的参数是：KeepAliveTimeout），max是最多一百次请求。这两个限制条件，只要满足一个就会强制断掉连接。")]),e._v(" "),r("p",[e._v("就是在timeout时间内又有新的请求过来，同时max会自动减1，直到为0，强制断掉")]),e._v(" "),r("h3",{attrs:{id:"spi"}},[e._v("SPI")]),e._v(" "),r("pre",[r("code",[e._v("  API （Application Programming Interface）在大多数情况下，都是实现方制定接口并完成对接口的实现，调用方仅仅依赖接口调用，且无权选择不同实现。 从使用人员上来说，API 直接被应用开发人员使用。\n\n  SPI （Service Provider Interface）是调用方来制定接口规范，提供给外部来实现，调用方在调用时则选择自己需要的外部实现。  从使用人员上来说，SPI 被框架扩展人员使用。 \n")])]),e._v(" "),r("p",[e._v("然后需要在resources目录下新建META-INF/services目录，并且在这个目录下新建一个与上述接口的全限定名一致的文件，在这个文件中写入接口的实现类的全限定名 写多个的话会遍历执行")]),e._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('  public static void main(String[] args) {\n          ServiceLoader<UploadCDN> uploadCDN = ServiceLoader.load(UploadCDN.class);\n          for (UploadCDN u : uploadCDN) {\n              u.upload("filePath");\n          }\n      }\n')])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br"),r("span",{staticClass:"line-number"},[e._v("2")]),r("br"),r("span",{staticClass:"line-number"},[e._v("3")]),r("br"),r("span",{staticClass:"line-number"},[e._v("4")]),r("br"),r("span",{staticClass:"line-number"},[e._v("5")]),r("br"),r("span",{staticClass:"line-number"},[e._v("6")]),r("br")])]),r("h4",{attrs:{id:"javaspi弊端"}},[e._v("javaSPI弊端")]),e._v(" "),r("ul",[r("li",[e._v("只能遍历所有的实现，并全部实例化。")]),e._v(" "),r("li",[e._v("配置文件中只是简单的列出了所有的扩展实现，而没有给他们命名。导致在程序中很难去准确的引用它们。")]),e._v(" "),r("li",[e._v("扩展如果依赖其他的扩展，做不到自动注入和装配。")]),e._v(" "),r("li",[e._v("扩展很难和其他的框架集成，比如扩展里面依赖了一个Spring bean，原生的Java SPI不支持")])]),e._v(" "),r("h3",{attrs:{id:"dubbo-spi"}},[e._v("dubbo SPI")]),e._v(" "),r("h4",{attrs:{id:"几个概念"}},[e._v("几个概念")]),e._v(" "),r("pre",[r("code",[e._v("  （1）扩展点：一个接口。\n\n  （2）扩展：扩展（接口）的实现。\n\n  （3）扩展自适应实例：其实就是一个Extension的代理，它实现了扩展点接口。在调用扩展点的接口方法时，会根据实际的参数来决定要使用哪个扩展。dubbo会根据接口中的参数，自动地决定选择哪个实现。\n\n  （4）@SPI:该注解作用于扩展点的接口上，表明该接口是一个扩展点。\n\n  （5）@Adaptive：@Adaptive注解用在扩展接口的方法上。表示该方法是一个自适应方法。Dubbo在为扩展点生成自适应实例时，如果方法有@Adaptive注解，会为该方法生成对应的代码。\n")])]),e._v(" "),r("p",[e._v("ExtensionLoader 实现")]),e._v(" "),r("ul",[r("li",[e._v("getAdaptiveExtension 获取适配类型")]),e._v(" "),r("li",[e._v("根据类型获取ExtensionLoader实例，如果类型是ExtensionFactory则objectFactory为null，否则为ExtensionFactory的适配类型实现")]),e._v(" "),r("li",[e._v("getAdaptiveExtension ExtensionLoader获取绑定类型的适配类型实现")]),e._v(" "),r("li",[e._v("cachedAdaptiveInstance 适配类型实现实例缓存获取，如果缓存为空则创建并缓存")]),e._v(" "),r("li",[e._v("createAdaptiveExtension 创建适配类型实例")]),e._v(" "),r("li",[e._v("getAdaptiveExtensionClass 获取适配类型class")]),e._v(" "),r("li",[e._v("getExtensionClasses 获取扩展类集合")]),e._v(" "),r("li",[e._v("cachedClasses 扩展类集合缓存获取，不存在则加载并缓存")]),e._v(" "),r("li",[e._v("loadExtensionClasses 加载扩展类缓存，如果绑定类型SPI注解不为空，并且SPI的value不为空，逗号分隔切分，如果发现大于一个值，抛出异常，不予许有多个默认值，如果存在且为一个value，则作为默认实现的key：cachedDefaultName")]),e._v(" "),r("li",[e._v("loadFile 加载扩展类，目录顺序：internal/，META-INF/dubbo/，META-INF/services/")])]),e._v(" "),r("p",[r("img",{attrs:{src:"/img/dubbo/dubbo_spi_1.png",alt:"dubbo_api"}})]),e._v(" "),r("h4",{attrs:{id:"总结"}},[e._v("总结")]),e._v(" "),r("ul",[r("li",[r("p",[e._v("KeepAlive 机制是在网络层面保证了连接的可用性，但站在应用框架层面我们认为这还不够。主要体现在两个方面：")])]),e._v(" "),r("li",[r("p",[e._v("KeepAlive 的开关是在应用层开启的，但是具体参数(如重试测试，重试间隔时间)的设置却是操作系统级别的，位于操作系统的 /etc/sysctl.conf 配置中，这对于应用来说不够灵活。")])]),e._v(" "),r("li",[r("p",[e._v("KeepAlive 的保活机制只在链路空闲的情况下才会起到作用，假如此时有数据发送，且物理链路已经不通，操作系统这边的链路状态还是 ESTABLISHED，这时会发生什么？自然会走 TCP 重传机制，要知道默认的 TCP 超时重传，指数退避算法也是一个相当长的过程。")])]),e._v(" "),r("li",[r("p",[e._v("KeepAlive 本身是面向网络的，并不是面向于应用的，当连接不可用时，可能是由于应用本身 GC 问题，系统 load 高等情况，但网络仍然是通的，此时，应用已经失去了活性，所以连接自然应该认为是不可用的。")])])]),e._v(" "),r("h2",{attrs:{id:"服务暴露流程"}},[e._v("服务暴露流程")]),e._v(" "),r("h4",{attrs:{id:"_1-spring容器启动完成，触发onapplicationevent方法，执行doexport方法开始暴露服务"}},[e._v("1.Spring容器启动完成，触发onApplicationEvent方法，执行doExport方法开始暴露服务")]),e._v(" "),r("h4",{attrs:{id:"_2-获取注册中心地址，把服务暴露在协议端口"}},[e._v("2.获取注册中心地址，把服务暴露在协议端口")]),e._v(" "),r("h4",{attrs:{id:"_3-获取执行器，然后进一步包装，通过registryprotocol-export暴露包装后的执行器"}},[e._v("3.获取执行器，然后进一步包装，通过RegistryProtocol.export暴露包装后的执行器")]),e._v(" "),r("h4",{attrs:{id:"_4-通过dubboprotocol启动netty服务器"}},[e._v("4.通过DubboProtocol启动netty服务器")]),e._v(" "),r("h4",{attrs:{id:"_5-通过providerconsumerregtable注册服务提供者"}},[e._v("5.通过ProviderConsumerRegTable注册服务提供者")]),e._v(" "),r("ul",[r("li",[e._v("ServiceBean实现了ApplicationListener接口的onApplicationEvent方法，spring容器启动完后会执行服务暴露方法")])]),e._v(" "),r("p",[e._v("doExportUrlsFor1Protocol方法关键代码：")]),e._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('// 获取执行器\nInvoker<?> invoker = proxyFactory.getInvoker(this.ref, this.interfaceClass, registryURL.addParameterAndEncoded("export", url.toFullString()));\n// 进一步包装\nDelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this);\n// 暴露invoker\nExporter<?> exporter = protocol.export(wrapperInvoker);\nthis.exporters.add(exporter);\n')])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br"),r("span",{staticClass:"line-number"},[e._v("2")]),r("br"),r("span",{staticClass:"line-number"},[e._v("3")]),r("br"),r("span",{staticClass:"line-number"},[e._v("4")]),r("br"),r("span",{staticClass:"line-number"},[e._v("5")]),r("br"),r("span",{staticClass:"line-number"},[e._v("6")]),r("br"),r("span",{staticClass:"line-number"},[e._v("7")]),r("br")])]),r("p",[e._v("可以看到，invoker实际上就是一个代理对象，封装了我们写的Service实现类")]),e._v(" "),r("ul",[r("li",[r("p",[e._v("protocol.export过程:通过RegistryProtocol.export()暴露,然后通过DubboProtocol暴露DubboProtocol.export重要代码")])]),e._v(" "),r("li",[r("p",[e._v("然后通过ProviderConsumerRegTable.registerProvider(originInvoker, registryUrl, registedProviderUrl);注册服务提供者")])])]),e._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("\npublic static void registerProvider(Invoker invoker, URL registryUrl, URL providerUrl) {\n    // 封装invoker\n    ProviderInvokerWrapper wrapperInvoker = new ProviderInvokerWrapper(invoker, registryUrl, providerUrl);\n    // 获取服务名(service接口全类名:版本)\n    String serviceUniqueName = providerUrl.getServiceKey();\n    Set<ProviderInvokerWrapper> invokers = (Set)providerInvokers.get(serviceUniqueName);\n    if (invokers == null) {\n        providerInvokers.putIfAbsent(serviceUniqueName, new ConcurrentHashSet());\n        invokers = (Set)providerInvokers.get(serviceUniqueName);\n    }\n \n    // 把invoker放到内存\n    invokers.add(wrapperInvoker);\n}\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br"),r("span",{staticClass:"line-number"},[e._v("2")]),r("br"),r("span",{staticClass:"line-number"},[e._v("3")]),r("br"),r("span",{staticClass:"line-number"},[e._v("4")]),r("br"),r("span",{staticClass:"line-number"},[e._v("5")]),r("br"),r("span",{staticClass:"line-number"},[e._v("6")]),r("br"),r("span",{staticClass:"line-number"},[e._v("7")]),r("br"),r("span",{staticClass:"line-number"},[e._v("8")]),r("br"),r("span",{staticClass:"line-number"},[e._v("9")]),r("br"),r("span",{staticClass:"line-number"},[e._v("10")]),r("br"),r("span",{staticClass:"line-number"},[e._v("11")]),r("br"),r("span",{staticClass:"line-number"},[e._v("12")]),r("br"),r("span",{staticClass:"line-number"},[e._v("13")]),r("br"),r("span",{staticClass:"line-number"},[e._v("14")]),r("br"),r("span",{staticClass:"line-number"},[e._v("15")]),r("br")])]),r("h2",{attrs:{id:"服务调用过程"}},[e._v("服务调用过程")]),e._v(" "),r("h4",{attrs:{id:"_1-代理对象把请求方法、请求参数进行封装"}},[e._v("1 代理对象把请求方法、请求参数进行封装")]),e._v(" "),r("h4",{attrs:{id:"_2-如果有filter，执行filter相关处理"}},[e._v("2 如果有Filter，执行Filter相关处理")]),e._v(" "),r("h4",{attrs:{id:"_3-执行clusterinvoker，如果封装了多个invoker会通过负载均衡策略选出一个invoker来执行"}},[e._v("3 执行ClusterInvoker，如果封装了多个Invoker会通过负载均衡策略选出一个invoker来执行")]),e._v(" "),r("h4",{attrs:{id:"_4-调用其他filter进行调用信息统计"}},[e._v("4 调用其他filter进行调用信息统计")]),e._v(" "),r("h4",{attrs:{id:"_5-协议invoker进行调用-dubboinvoker、rmiinvoker、hessianinvoker等"}},[e._v("5 协议invoker进行调用(DubboInvoker、RmiInvoker、HessianInvoker等)")]),e._v(" "),r("h4",{attrs:{id:"_6-client通过netty客户端连接到服务端发送请求"}},[e._v("6 Client通过Netty客户端连接到服务端发送请求")])])},[],!1,null,null,null);t.default=i.exports}}]);