(window.webpackJsonp=window.webpackJsonp||[]).push([[138],{411:function(v,_,s){"use strict";s.r(_);var t=s(10),a=Object(t.a)({},function(){var v=this,_=v.$createElement,s=v._self._c||_;return s("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[s("h3",{attrs:{id:"设计模式"}},[v._v("设计模式")]),v._v(" "),s("h4",{attrs:{id:"模版方法"}},[v._v("模版方法")]),v._v(" "),s("h4",{attrs:{id:"策略模式"}},[v._v("策略模式")]),v._v(" "),s("pre",[s("code",[v._v("传入具体实现饿的接口然后实现，配置\n")])]),v._v(" "),s("h4",{attrs:{id:"装饰模式"}},[v._v("装饰模式")]),v._v(" "),s("h4",{attrs:{id:"工厂模式"}},[v._v("工厂模式")]),v._v(" "),s("pre",[s("code",[v._v("建造具体的类\n")])]),v._v(" "),s("h4",{attrs:{id:"委派模式"}},[v._v("委派模式")]),v._v(" "),s("pre",[s("code",[v._v("找到某一种委派的类执行业务  \n")])]),v._v(" "),s("h3",{attrs:{id:"redis-主从的分布式锁怎么用"}},[v._v("redis 主从的分布式锁怎么用")]),v._v(" "),s("p",[v._v("redisson的redlock")]),v._v(" "),s("h3",{attrs:{id:"遇到的问题"}},[v._v("遇到的问题")]),v._v(" "),s("p",[v._v("数据库->死锁 修改索引 加外部锁")]),v._v(" "),s("h3",{attrs:{id:"aqs"}},[v._v("AQS")]),v._v(" "),s("h3",{attrs:{id:"双亲委派模型"}},[v._v("双亲委派模型")]),v._v(" "),s("p",[v._v("从父类开始调用"),s("br"),v._v("\nBootstrap(对java不可见)\n->Extension（sun.security.ec.SunEC.class.getClassLoader）\n->Application（ClassLoader.getSystemClassLoader()）\n->Custom\nloadClass defineClass findClass")]),v._v(" "),s("h4",{attrs:{id:"破坏双亲委派"}},[v._v("破坏双亲委派")]),v._v(" "),s("p",[v._v("复写findClass（不破坏双亲委派）\n用上下文类加载器")]),v._v(" "),s("h5",{attrs:{id:"classloader"}},[v._v("classLoader")]),v._v(" "),s("p",[v._v("ExtClassloader extends UrlClassLoader extends ClassLoader\nAppClassloader extends UrlClassLoader extends ClassLoader")]),v._v(" "),s("h3",{attrs:{id:"热部署"}},[v._v("热部署")]),v._v(" "),s("p",[v._v("Class.forName()->SystemDictionary::resove_from_stream")]),v._v(" "),s("h3",{attrs:{id:"读已提交和不可重复度区别"}},[v._v("读已提交和不可重复度区别")]),v._v(" "),s("p",[v._v("读已提交每次快照读都是最新读数据\n不可重复度每次快照读都是事务刚生成读数据\n读已提交事务更新读时候如果没有索引可能会锁表")]),v._v(" "),s("h3",{attrs:{id:"hashmap-扩容-为什么线程不安全"}},[v._v("HashMap 扩容 为什么线程不安全")]),v._v(" "),s("pre",[s("code",[v._v("-  1.7 transfer 头插法 造成环形链和数据丢失的情况\n-  1.8 尾插 会发生数据覆盖的情况\n")])]),v._v(" "),s("h3",{attrs:{id:"hashmap-解决hash冲突"}},[v._v("HashMap 解决hash冲突")]),v._v(" "),s("ul",[s("li",[v._v("hash冲突结果方法  链地址法 再hash法 建立公共溢出区 开放地址法（向前找地址存储）")]),v._v(" "),s("li",[v._v("1.8是链地址法 链表长度大于8且hashmap容量得大于64会转换红黑树")])]),v._v(" "),s("h3",{attrs:{id:"垃圾回收"}},[v._v("垃圾回收")]),v._v(" "),s("ul",[s("li",[v._v("8:1:1 98%的对象朝生夕死")]),v._v(" "),s("li",[v._v("15次回收 四个二进制位")])]),v._v(" "),s("h3",{attrs:{id:"分布式事务"}},[v._v("分布式事务")]),v._v(" "),s("p",[v._v("定义了三个角色 AP(应用程序) RM(资源管理器) TM(事务管理器)")]),v._v(" "),s("h4",{attrs:{id:"_2pc-two-phase-commit-x-open了定义的规范和api接口"}},[v._v("2PC Two-Phase-Commit) X/Open了定义的规范和API接口")]),v._v(" "),s("ul",[s("li",[v._v("协议 XA  以及 XT")])]),v._v(" "),s("h4",{attrs:{id:"saga"}},[v._v("Saga")]),v._v(" "),s("ul",[s("li",[v._v("需要定义正常操作以及补偿操作，开发量比XA大")])]),v._v(" "),s("h4",{attrs:{id:"tcc-try-confirm-cancel"}},[v._v("TCC try confirm cancel")]),v._v(" "),s("ul",[s("li",[s("p",[v._v("并发度较高，无长期资源锁定。")])]),v._v(" "),s("li",[s("p",[v._v("开发量较大，需要提供Try/Confirm/Cancel接口。")])]),v._v(" "),s("li",[s("p",[v._v("一致性较好，不会发生SAGA已扣款最后又转账失败的情况")])]),v._v(" "),s("li",[s("p",[v._v("TCC适用于订单类业务，对中间状态有约束的业务")])])]),v._v(" "),s("h4",{attrs:{id:"本地消息表-or-事务消息"}},[v._v("本地消息表 or 事务消息")]),v._v(" "),s("h4",{attrs:{id:"最大努力通知"}},[v._v("最大努力通知")]),v._v(" "),s("ul",[s("li",[v._v("既有回调通知，也有交易查询接口")])]),v._v(" "),s("h4",{attrs:{id:"at事务模式"}},[v._v("AT事务模式")]),v._v(" "),s("ul",[s("li",[v._v("seata-at 业务无需编写各类补偿操作，回滚由框架自动完成，缺点也类似AT，存在较长时间的锁，不满足高并发的场景")])]),v._v(" "),s("h3",{attrs:{id:"事务传播级别"}},[v._v("事务传播级别")]),v._v(" "),s("ul",[s("li",[v._v("required  有就加入 没有新建")]),v._v(" "),s("li",[v._v("required—new 新建")]),v._v(" "),s("li",[v._v("nested 嵌套")]),v._v(" "),s("li",[v._v("supports 非事务")]),v._v(" "),s("li",[v._v("not support 非事务 当前存在就挂起来")]),v._v(" "),s("li",[v._v("mandatofy 强制事务")]),v._v(" "),s("li",[v._v("never 不启动事务")])])])},[],!1,null,null,null);_.default=a.exports}}]);