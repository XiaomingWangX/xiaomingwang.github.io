(window.webpackJsonp=window.webpackJsonp||[]).push([[103],{376:function(v,_,l){"use strict";l.r(_);var e=l(10),a=Object(e.a)({},function(){var v=this,_=v.$createElement,l=v._self._c||_;return l("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[l("h3",{attrs:{id:"garbage-collector-gc-tuning"}},[v._v("Garbage Collector GC tuning")]),v._v(" "),l("h4",{attrs:{id:"_1-什么是垃圾"}},[v._v("1.什么是垃圾")]),v._v(" "),l("blockquote",[l("p",[v._v("C语言申请内存：malloc free")]),v._v(" "),l("p",[v._v("C++： new delete")]),v._v(" "),l("p",[v._v("c/C++ 手动回收内存")]),v._v(" "),l("p",[v._v("Java: new ？")]),v._v(" "),l("p",[v._v("自动内存回收，编程上简单，系统不容易出错，手动释放内存，容易出两种类型的问题：")]),v._v(" "),l("ol",[l("li",[v._v("忘记回收")]),v._v(" "),l("li",[v._v("多次回收")])])]),v._v(" "),l("h4",{attrs:{id:"_2-如何定位垃圾"}},[v._v("2.如何定位垃圾")]),v._v(" "),l("ol",[l("li",[v._v("引用计数（ReferenceCount）")]),v._v(" "),l("li",[v._v("根可达算法(RootSearching) jvm 用的")])]),v._v(" "),l("h4",{attrs:{id:"_3-常见的垃圾回收算法"}},[v._v("3.常见的垃圾回收算法")]),v._v(" "),l("ol",[l("li",[v._v("标记清除(mark sweep) -(根可达) 位置不连续 产生碎片 效率偏低（两遍扫描）(存活对象比较多的情况下 效率高)")]),v._v(" "),l("li",[v._v("拷贝算法 (copying) -(根可达)  没有碎片，浪费空间(一分为二 适合存活对象较少 例如eden区)")]),v._v(" "),l("li",[v._v("标记压缩(mark compact)(根可达)  - 没有碎片，效率偏低 不会产生碎片,方便对象分配（两遍扫描，指针需要调整(移动对象)）")])]),v._v(" "),l("h4",{attrs:{id:"_4-jvm内存分代模型（用于分代垃圾回收算法）"}},[v._v("4.JVM内存分代模型（用于分代垃圾回收算法）")]),v._v(" "),l("ol",[l("li",[v._v("部分垃圾回收器使用的模型")])]),v._v(" "),l("p",[l("img",{attrs:{src:"/img/jvm/gc.png",alt:"gc.png"}}),v._v("  新生代和老年代默认 1:3")]),v._v(" "),l("blockquote",[l("p",[v._v("除Epsilon ZGC Shenandoah 这三个之外的GC都是使用逻辑分代模型")]),v._v(" "),l("p",[v._v("G1是逻辑分代，物理不分代")]),v._v(" "),l("p",[v._v("除此之外不仅逻辑分代，而且物理分代")])]),v._v(" "),l("p",[v._v("1个对象从出生到消亡=> 先尝试栈上分配(如果栈上分配不下 就去eden区 大对象直接老年代)\n=>s0-s1之前的复制年龄超过限制时进入老年代(参数 -XX:MaxTenuringThreshold配置)")]),v._v(" "),l("p",[v._v("首先 栈上分配(线程私有小对象 无逃逸 支持标量替换)\n如果分配不了-> 线程本地分配TLAB(Thread Local Allocation Buffer) [占用eden 默认1%  多线程的时候不用竞争eden可以申请空间,提高效率 小对象]\n然后 老年代分配大对象")]),v._v(" "),l("ol",{attrs:{start:"2"}},[l("li",[l("p",[v._v("新生代 + 老年代 + 永久代（1.7）Perm Generation/ 元数据区(1.8) Metaspace")])]),v._v(" "),l("li",[l("p",[v._v("gc收集器")])])]),v._v(" "),l("p",[l("img",{attrs:{src:"/img/jvm/gc2.png",alt:"gc2.png"}})]),v._v(" "),l("p",[v._v("JDK刚诞生 serial + serial old(老年代)")]),v._v(" "),l("p",[v._v("之后 parallel scavenge +parallel old(老年代)")]),v._v(" "),l("p",[v._v("然后 parnew +cms(老年代)")]),v._v(" "),l("p",[v._v("1.8默认的垃圾回收：parallel scavenge+ Parallel Old")]),v._v(" "),l("h5",{attrs:{id:"serial-serial-old"}},[v._v("serial + serial old:")]),v._v(" "),l("p",[v._v("都是单线程 (新生代: 拷贝算法)(老年代: 标记清除或者标记压缩(标记整理))")]),v._v(" "),l("h5",{attrs:{id:"parallel-scavenge-parallel-old"}},[v._v("parallel scavenge +parallel old:")]),v._v(" "),l("p",[v._v("多线程的 (新生代: 拷贝算法)(老年代: 标记压缩(标记整理))")]),v._v(" "),l("h5",{attrs:{id:"parnew-cms"}},[v._v("parnew +cms")]),v._v(" "),l("p",[v._v("parnew 和 cms配合 (parnew 可以在cms运行间隙运行)\ncms 是1.4版本后期引入(问题比较多)\ncms => 初始标记(标志 root 会STW) =>并发标记(和用户进程一起)\n=>重新标记(标记并发标记中出现的垃圾  会STW)=>并发清理(会产生浮动垃圾)")]),v._v(" "),l("h5",{attrs:{id:"cms"}},[v._v("cms")]),v._v(" "),l("h4",{attrs:{id:"_4-jvm内存分代模型（用于分代垃圾回收算法）-2"}},[v._v("4.JVM内存分代模型（用于分代垃圾回收算法）")]),v._v(" "),l("ol",[l("li",[l("p",[v._v("部分垃圾回收器使用的模型")]),v._v(" "),l("blockquote",[l("p",[v._v("除Epsilon ZGC Shenandoah之外的GC都是使用逻辑分代模型")]),v._v(" "),l("p",[v._v("G1是逻辑分代，物理不分代")]),v._v(" "),l("p",[v._v("除此之外不仅逻辑分代，而且物理分代")])])]),v._v(" "),l("li",[l("p",[v._v("新生代 + 老年代 + 永久代（1.7）Perm Generation/ 元数据区(1.8) Metaspace")]),v._v(" "),l("ol",[l("li",[v._v("永久代 元数据 - Class")]),v._v(" "),l("li",[v._v("永久代必须指定大小限制 ，元数据可以设置，也可以不设置，无上限（受限于物理内存）")]),v._v(" "),l("li",[v._v("字符串常量 1.7 - 永久代，1.8 - 堆")]),v._v(" "),l("li",[v._v("MethodArea逻辑概念 - 永久代、元数据")])])]),v._v(" "),l("li",[l("p",[v._v("新生代 = Eden + 2个suvivor区")]),v._v(" "),l("ol",[l("li",[v._v("YGC回收之后，大多数的对象会被回收，活着的进入s0")]),v._v(" "),l("li",[v._v("再次YGC，活着的对象eden + s0 -> s1")]),v._v(" "),l("li",[v._v("再次YGC，eden + s1 -> s0")]),v._v(" "),l("li",[v._v("年龄足够 -> 老年代 （15 CMS 6）")]),v._v(" "),l("li",[v._v("s区装不下 -> 老年代")])])]),v._v(" "),l("li",[l("p",[v._v("老年代")]),v._v(" "),l("ol",[l("li",[v._v("顽固分子")]),v._v(" "),l("li",[v._v("老年代满了FGC Full GC")])])]),v._v(" "),l("li",[l("p",[v._v("GC Tuning (Generation)")]),v._v(" "),l("ol",[l("li",[v._v("尽量减少FGC")]),v._v(" "),l("li",[v._v("MinorGC = YGC")]),v._v(" "),l("li",[v._v("MajorGC = FGC")])])])]),v._v(" "),l("h4",{attrs:{id:"_5-常见的垃圾回收器"}},[v._v("5.常见的垃圾回收器")]),v._v(" "),l("ol",[l("li",[v._v("JDK诞生 Serial追随 提高效率，诞生了PS，为了配合CMS，诞生了PN，CMS是1.4版本后期引入，CMS是里程碑式的GC，它开启了并发回收的过程，但是CMS毛病较多，因此目前任何一个JDK版本默认是CMS\n并发垃圾回收是因为无法忍受STW")]),v._v(" "),l("li",[v._v("Serial 年轻代 串行回收")]),v._v(" "),l("li",[v._v("PS 年轻代 并行回收")]),v._v(" "),l("li",[v._v("ParNew 年轻代 配合CMS的并行回收")]),v._v(" "),l("li",[v._v("SerialOld")]),v._v(" "),l("li",[v._v("ParallelOld")]),v._v(" "),l("li",[v._v("ConcurrentMarkSweep 老年代 并发的， 垃圾回收和应用程序同时运行，降低STW的时间(200ms)\nCMS问题比较多，所以现在没有一个版本默认是CMS，只能手工指定\nCMS既然是MarkSweep，就一定会有碎片化的问题，碎片到达一定程度，CMS的老年代分配对象分配不下的时候，使用SerialOld 进行老年代回收\n想象一下：\nPS + PO -> 加内存 换垃圾回收器 -> PN + CMS + SerialOld（几个小时 - 几天的STW）\n几十个G的内存，单线程回收 -> G1 + FGC 几十个G -> 上T内存的服务器 ZGC\n算法：三色标记 + Incremental Update")]),v._v(" "),l("li",[v._v("G1(10ms) 1.7才有  1.8完善  1.9默认\n算法：三色标记 + SATB")]),v._v(" "),l("li",[v._v("ZGC (1ms) PK C++\n算法：ColoredPointers + LoadBarrier")]),v._v(" "),l("li",[v._v("Shenandoah\n算法：ColoredPointers + WriteBarrier")]),v._v(" "),l("li",[v._v("Eplison")]),v._v(" "),l("li",[v._v("PS 和 PN区别的延伸阅读：\n▪"),l("a",{attrs:{href:"https://docs.oracle.com/en/java/javase/13/gctuning/ergonomics.html",target:"_blank",rel:"noopener noreferrer"}},[v._v("https://docs.oracle.com/en/java/javase/13/gctuning/ergonomics.html#GUID-3D0BB91E-9BFF-4EBB-B523-14493A860E73"),l("OutboundLink")],1)]),v._v(" "),l("li",[v._v("垃圾收集器跟内存大小的关系\n"),l("ol",[l("li",[v._v("Serial 几十兆")]),v._v(" "),l("li",[v._v("PS 上百兆 - 几个G")]),v._v(" "),l("li",[v._v("CMS - 20G")]),v._v(" "),l("li",[v._v("G1 - 上百G")]),v._v(" "),l("li",[v._v("ZGC - 4T - 16T（JDK13）")])])])]),v._v(" "),l("p",[v._v("1.8默认的垃圾回收：PS + ParallelOld")]),v._v(" "),l("h3",{attrs:{id:"定位"}},[v._v("定位")]),v._v(" "),l("ul",[l("li",[v._v("jps 或者jcmd获取pid")]),v._v(" "),l("li",[v._v("jmap -histo pid  用来查看内存信息，实例个数以及占用内存大")]),v._v(" "),l("li",[v._v("jinfo -flag pid  看jvm 参数   jinfo -flag option pid 可以看具体参数")])])])},[],!1,null,null,null);_.default=a.exports}}]);