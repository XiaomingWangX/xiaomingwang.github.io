(window.webpackJsonp=window.webpackJsonp||[]).push([[102],{375:function(v,a,t){"use strict";t.r(a);var r=t(10),_=Object(r.a)({},function(){var v=this,a=v.$createElement,t=v._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h3",{attrs:{id:"java加载到执行"}},[v._v("JAVA加载到执行")]),v._v(" "),t("h4",{attrs:{id:"_1-javac-xx-class"}},[v._v("1 javac xx.class")]),v._v(" "),t("h4",{attrs:{id:"_2-类加载器加载"}},[v._v("2.类加载器加载")]),v._v(" "),t("ul",[t("li",[v._v("Bootstarp 加载$JAVA_HOME/jre/lib/rt.jar里所有class,不是Classloader子类")]),v._v(" "),t("li",[v._v("Extension 加载java平台中扩展功能的一些jar，包括$JAVA_HOME/jre/lib/*.jar或者-Djava.ext.dirs指定目录下的jar包")]),v._v(" "),t("li",[v._v("Application 加载classpath中指定的jar以及目录中class")]),v._v(" "),t("li",[v._v("Custom自定义")])]),v._v(" "),t("h4",{attrs:{id:"连接"}},[v._v("连接")]),v._v(" "),t("ul",[t("li",[v._v("验证：字节码检查器检查生成的字节码是否正确，验证失败则会验证失败")]),v._v(" "),t("li",[v._v("准备：对于所有静态变量内存分配和默认值分配")]),v._v(" "),t("li",[v._v("识别：解析或者识别是从运行时常量池的符号引用中动态具体值的过程")])]),v._v(" "),t("h4",{attrs:{id:"初始化"}},[v._v("初始化")]),v._v(" "),t("ul",[t("li",[v._v("类或者接口的初始化由执行类或者接口初始化方法构成，这里所有的静态变量与原来的值都将被替换，静态块将被执行")])]),v._v(" "),t("h4",{attrs:{id:"执行引擎"}},[v._v("执行引擎")]),v._v(" "),t("h4",{attrs:{id:"os硬件"}},[v._v("os硬件")]),v._v(" "),t("h3",{attrs:{id:"对象的创建过程"}},[v._v("对象的创建过程")]),v._v(" "),t("p",[v._v("1.class loading   *** new ***  之后 加载到内存")]),v._v(" "),t("p",[v._v("2.class linking(verification(校验),preparation(静态变量设默认值) ,resolution(解析))")]),v._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[v._v("class Initializing( 初始化 ->静态变量设为初始值 执行静态语句块)\n----- 这里是load到内存 （方法区）？\n4.申请对象内存")])]),v._v(" "),t("p",[v._v("5.成员变量赋默认值")]),v._v(" "),t("p",[v._v("6.调用构造方法 (init)\n1.成员变量顺序赋初始值（先初始化成员变量）\n2.执行构造方法语句")]),v._v(" "),t("h3",{attrs:{id:"原子性操作底层"}},[v._v("原子性操作底层")]),v._v(" "),t("h4",{attrs:{id:"jvm封装了8个指令-深入理解java虚拟机目前放弃了"}},[v._v("jvm封装了8个指令 深入理解java虚拟机目前放弃了")]),v._v(" "),t("ul",[t("li",[v._v("lock ：锁定 把主内存的一个变量标志为一个线程独享的状态")]),v._v(" "),t("li",[v._v("unlock ：解锁 把驻内存的一个变量释放出来")]),v._v(" "),t("li",[v._v("read ：读取 将驻内存的变量读到工作内存中")]),v._v(" "),t("li",[v._v("load ：加载 把工作内存中的变量加载到副本中")]),v._v(" "),t("li",[v._v("use ：使用 当执行引擎需要使用到一个变量时，将工作内存中的变量的值穿")]),v._v(" "),t("li",[v._v("assign ：赋值 将执行引擎需要使用到一个变量时，将工作内存中的变量的值传递给执行引擎")]),v._v(" "),t("li",[v._v("store ：存储 把工作内存中的变量值传到主内存中")]),v._v(" "),t("li",[v._v("write ：写入 将store得到的值放到主内存的变量里")])]),v._v(" "),t("h4",{attrs:{id:"八种原子操作下的八种操作规则"}},[v._v("八种原子操作下的八种操作规则")]),v._v(" "),t("p",[v._v("1.read和load,store和write必须同时出现,并且按照顺序执行")]),v._v(" "),t("p",[v._v("2.不允许线程丢弃最后一个assign操作,在进行assign操作后,必须进行store和write")]),v._v(" "),t("p",[v._v("3.如果一个线程的工作内存中的一个变量没有发生assign操作,则不能够发生store和write")]),v._v(" "),t("p",[v._v("4.在工作内存中,如果对一个变量使用use或者store操作,则必须先执行assign和load操作")]),v._v(" "),t("p",[v._v("5.一个主内存中的变量在同一时刻只能被一个线程进行lock操作,但是这个线程可以进行多次lock操作,并且执行相应次数的unlock操作后,变量才会被解锁.")]),v._v(" "),t("p",[v._v("6.如果对一个量进行lock操作,将会清空此变量在其他线程工作内存中的值,这些线程在使用之前必须进行load或assign操作")]),v._v(" "),t("p",[v._v("7.一个线程如果没有对一个变量进行lock操作,则这个线程也不能对这个变量进行unlock操作")]),v._v(" "),t("p",[v._v("8.一个线程在进行unlock操作之前,必须先执行store和write操作")]),v._v(" "),t("h4",{attrs:{id:"硬件层面的“内存屏障”-x86-intel"}},[v._v("硬件层面的“内存屏障” x86 intel :")]),v._v(" "),t("ul",[t("li",[v._v("sfence：即写屏障(Store Barrier)，在写指令之后插入写屏障，能让写入缓存的最新数据写回到主内存，以保证写入的数据立刻对其他线程可见")]),v._v(" "),t("li",[v._v("lfence：即读屏障(Load Barrier)，在读指令前插入读屏障，可以让高速缓存中的数据失效，重新从主内存加载数据，以保证读取的是最新的数据。")]),v._v(" "),t("li",[v._v("mfence：即全能屏障(modify/mix Barrier )，兼具sfence和lfence的功能")]),v._v(" "),t("li",[v._v("lock 前缀：lock不是内存屏障，而是一种锁。执行时会锁住内存子系统来确保执行顺序，甚至跨多个CPU。")])]),v._v(" "),t("h4",{attrs:{id:"jvm封装了四个指令-storestore-storeload-loadstore-loadload"}},[v._v("jvm封装了四个指令 StoreStore/StoreLoad/LoadStore/LoadLoad")]),v._v(" "),t("ul",[t("li",[v._v("LoadLoad Barriers 示例：Load1; LoadLoad; Load2")])]),v._v(" "),t("p",[v._v("该屏障确保Load1数据的装载先于Load2及其后所有装载指令的的操作")]),v._v(" "),t("ul",[t("li",[v._v("StoreStore Barriers 示例：Store1; StoreStore; Store2")])]),v._v(" "),t("p",[v._v("该屏障确保Store1立刻刷新数据到内存(使其对其他处理器可见)的操作先于Store2及其后所有存储指令的操作")]),v._v(" "),t("ul",[t("li",[v._v("LoadStore Barriers 示例：Load1; LoadStore; Store2")])]),v._v(" "),t("p",[v._v("确保Load1的数据装载先于Store2及其后所有的存储指令刷新数据到内存的操作")]),v._v(" "),t("ul",[t("li",[v._v("StoreLoad Barriers 示例：Store1; StoreLoad; Load2")])]),v._v(" "),t("p",[v._v("该屏障确保Store1立刻刷新数据到内存的操作先于Load2及其后所有装载装载指令的操作。")]),v._v(" "),t("p",[v._v("它会使该屏障之前的所有内存访问指令(存储指令和访问指令)完成之后,才执行该屏障之后的内存访问指令。")]),v._v(" "),t("h3",{attrs:{id:"volatile-实现细节"}},[v._v("volatile 实现细节")]),v._v(" "),t("h4",{attrs:{id:"字节码层面"}},[v._v("字节码层面")]),v._v(" "),t("p",[v._v("ACC_VOLATILE")]),v._v(" "),t("h4",{attrs:{id:"jvm层面"}},[v._v("JVM层面")]),v._v(" "),t("p",[v._v("LoadLoadBarrier\nvolatile 读操作\nLoadStoreBarrier")]),v._v(" "),t("p",[v._v("StoreStoreBarrier\nvolatile 写操作\nStoreLoadBarrier")]),v._v(" "),t("h4",{attrs:{id:"os和硬件层面"}},[v._v("OS和硬件层面")]),v._v(" "),t("p",[v._v("https://blog.csdn.net/qq_26222859/article/details/52235930\nhsdis 看汇编指令 - HotSpot Dis Assembler\nwindows lock 指令实现 | MESI实现")]),v._v(" "),t("h3",{attrs:{id:"synchronized-实现细节"}},[v._v("synchronized 实现细节")]),v._v(" "),t("h4",{attrs:{id:"字节码层面-2"}},[v._v("字节码层面")]),v._v(" "),t("p",[v._v("ACC_SYNCHRONIZED\nmonitorenter monitorexit")]),v._v(" "),t("h4",{attrs:{id:"jvm层面-2"}},[v._v("JVM层面")]),v._v(" "),t("p",[v._v("C C++ 调用了操作系统提供的同步指令")]),v._v(" "),t("h4",{attrs:{id:"os和硬件层面-2"}},[v._v("OS和硬件层面")]),v._v(" "),t("p",[v._v("x86 lock comxchg xxxx")]),v._v(" "),t("h3",{attrs:{id:"查看bytecode的方法"}},[v._v("查看ByteCode的方法")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("javap")])]),v._v(" "),t("li",[t("p",[v._v("JBE")])]),v._v(" "),t("li",[t("p",[v._v("JClassLin IDEA插件之一")])])]),v._v(" "),t("h3",{attrs:{id:"类什么时候初始化"}},[v._v("类什么时候初始化")]),v._v(" "),t("p",[v._v("– new getstatic putstatic invokestatic指令，访问final变量除外\n– java.lang.reflect对类进行反射调用时\n– 初始化子类的时候，父类首先初始化\n– 虚拟机启动时，被执行的主类必须初始化\n– 动态语言支持java.lang.invoke.MethodHandle解析的结果为\nREF_getstatic REF_putstatic REF_invokestatic的方法句柄时，该类必须初\n始化")]),v._v(" "),t("h3",{attrs:{id:"对象的内存布局"}},[v._v("对象的内存布局")]),v._v(" "),t("h4",{attrs:{id:"普通对象-注意两个指针压缩"}},[v._v("普通对象 注意两个指针压缩")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("对象头：markword  8字节")])]),v._v(" "),t("li",[t("p",[v._v("ClassPointer指针：-XX:+UseCompressedClassPointers(对象压缩指针) 为4字节 不开启为8字节")])]),v._v(" "),t("li",[t("p",[v._v("实例数据 instance")]),v._v(" "),t("ol",[t("li",[v._v("引用类型：-XX:+UseCompressedOops(引用指针压缩) 为4字节 不开启为8字节\nOops Ordinary Object Pointers")]),v._v(" "),t("li",[v._v("基本数据类型   就根据他的长度")])])]),v._v(" "),t("li",[t("p",[v._v("Padding对齐，对其为8的倍数")])])]),v._v(" "),t("h4",{attrs:{id:"数组对象-多一个数组长度"}},[v._v("数组对象 多一个数组长度")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("对象头：markword 8字节")])]),v._v(" "),t("li",[t("p",[v._v("ClassPointer指针同上")])]),v._v(" "),t("li",[t("p",[v._v("数组长度：4字节")])]),v._v(" "),t("li",[t("p",[v._v("数组数据")])]),v._v(" "),t("li",[t("p",[v._v("对齐 对其为8的倍数")])])]),v._v(" "),t("h3",{attrs:{id:"对象头-markword"}},[v._v("对象头 markword")]),v._v(" "),t("p",[t("img",{attrs:{src:"/img/jvm/markword.png",alt:"markword.png"}}),v._v(" 32位的\nmarkword 32位")]),v._v(" "),t("h4",{attrs:{id:"无锁"}},[v._v("无锁")]),v._v(" "),t("p",[v._v("对象hashcode25bit 分代年龄4bit   是否偏向锁1bit  锁标志位2bit")]),v._v(" "),t("h4",{attrs:{id:"轻量级锁"}},[v._v("轻量级锁")]),v._v(" "),t("p",[v._v("指向栈中锁记录的指针 30bit 锁标志位2bit")]),v._v(" "),t("h4",{attrs:{id:"重量级锁"}},[v._v("重量级锁")]),v._v(" "),t("p",[v._v("指向互斥量(重量级锁)的指针 30bit 锁标志位2bit")]),v._v(" "),t("h4",{attrs:{id:"偏向锁"}},[v._v("偏向锁")]),v._v(" "),t("p",[v._v("线程id 23bit  Epoch2bit  分代年龄4bit 是否偏向锁1bit  锁标志位2bit")]),v._v(" "),t("h4",{attrs:{id:"gc为什么默认年龄15-因为只有4bit-最大-15"}},[v._v("GC为什么默认年龄15 因为只有4bit 最大 15")]),v._v(" "),t("h3",{attrs:{id:"对象怎么定位"}},[v._v("对象怎么定位")]),v._v(" "),t("ol",[t("li",[v._v("句柄池  cms三色标记等会用")]),v._v(" "),t("li",[v._v("直接指针\n就HotSpot而言，他使用的是直接指针访问方式进行对象访问")])]),v._v(" "),t("h3",{attrs:{id:"对象分配过程"}},[v._v("对象分配过程")]),v._v(" "),t("ul",[t("li",[v._v("栈分配 如果大大话 TLAB")])]),v._v(" "),t("h3",{attrs:{id:"双亲委派机制"}},[v._v("双亲委派机制")]),v._v(" "),t("ul",[t("li",[v._v("在自己缓存里找")]),v._v(" "),t("li",[v._v("自己缓存没有去父类找")]),v._v(" "),t("li",[v._v("缓存都没有 从父类开始加载")])]),v._v(" "),t("h3",{attrs:{id:"内存溢出的原因"}},[v._v("内存溢出的原因")]),v._v(" "),t("ul",[t("li",[v._v("java.lang.OutOfMemoryError: ......java heap space.....   堆栈溢出，代码问题的可能性极⼤")]),v._v(" "),t("li",[v._v("java.lang.OutOfMemoryError: GC over head limit exceeded 系统处于⾼频的GC状态，\n⽽且回收的效果依然不佳的情况，就会开始报这个错误，这种情况⼀般是产⽣了很多不可以被释放的对象，\n有可能是引⽤使⽤不当导致，或申请⼤对象导致，但是java heap space的内存溢出有可能提前不会报这个错误，\n也就是可能内存就直接不够导致，⽽不是⾼频GC.")]),v._v(" "),t("li",[v._v("java.lang.OutOfMemoryError: Direct buffer memory  直接内存不⾜，因为jvm垃圾回收不会回收掉直接内存这部分的内存\n，所以可能原因是直接或间接使⽤了ByteBuffer中的allocateDirect⽅法的时候，⽽没有做clear")]),v._v(" "),t("li",[v._v("java.lang.StackOverflowError -    Xss设置的太⼩了")]),v._v(" "),t("li",[v._v("java.lang.OutOfMemoryError: unable to create new native thread 堆外内存不⾜，⽆法为线程分配内存区域")]),v._v(" "),t("li",[v._v("java.lang.OutOfMemoryError: request {} byte for {}out of swap 地址空间不够")]),v._v(" "),t("li",[v._v("java.lang.OutOfMemoryError: PermGen space jdk1.7之前才会出现的问题 ，\n原因是系统的代码⾮常多或引⽤的第三⽅包⾮常多、或代码中使⽤了⼤量的常量、或通过intern注⼊常量、\n或者通过动态代码加载等⽅法，导致常量池的膨胀")])]),v._v(" "),t("h3",{attrs:{id:"利用-jmc、jfr，可以实现jvm性能问题的准确定位。"}},[v._v("利用 JMC、JFR，可以实现jvm性能问题的准确定位。")]),v._v(" "),t("h4",{attrs:{id:"jmc-java-mission-control"}},[v._v("JMC:Java Mission Control")]),v._v(" "),t("h4",{attrs:{id:"jfr-java-flight-recorder（jfr）之前是一个商业特性，现在可以直接使用类比飞机上的黑匣子"}},[v._v("JFR:Java Flight Recorder（JFR）之前是一个商业特性，现在可以直接使用类比飞机上的黑匣子")]),v._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[v._v("    #  检查 标志位 \n    jcmd $pid VM.check_commercial_features\n    # 先解锁\n    jcmd $pid VM.unlock_commercial_features \n    jcmd $pid JFR.start  delay=10s duration=1m filename=xxx.jfr\n    \n    # name=myrecord settings=my-setting\n      \n    # delay 延迟启动时间，duration 持续采集时间 1分钟\n    # settings 使用指定的采集配置  \n    # $JAVA_HOME/jre/lib/jfr  default.jfc profile.jfc\n     \n    # \n    jcmd $pid JFR.stop name=myrecord \n    \n    jmc  打开指定的 jfr 文件\n    \n    主要包括7部分性能报告，分别是一般信息、内存、代码、线程、I/O、系统、GC类型，暂停时间，最短暂停时间、\n    平均暂停时间、最长暂停时间、IO  文件读写 套接字读写\n\n")])]),v._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[v._v("1")]),t("br"),t("span",{staticClass:"line-number"},[v._v("2")]),t("br"),t("span",{staticClass:"line-number"},[v._v("3")]),t("br"),t("span",{staticClass:"line-number"},[v._v("4")]),t("br"),t("span",{staticClass:"line-number"},[v._v("5")]),t("br"),t("span",{staticClass:"line-number"},[v._v("6")]),t("br"),t("span",{staticClass:"line-number"},[v._v("7")]),t("br"),t("span",{staticClass:"line-number"},[v._v("8")]),t("br"),t("span",{staticClass:"line-number"},[v._v("9")]),t("br"),t("span",{staticClass:"line-number"},[v._v("10")]),t("br"),t("span",{staticClass:"line-number"},[v._v("11")]),t("br"),t("span",{staticClass:"line-number"},[v._v("12")]),t("br"),t("span",{staticClass:"line-number"},[v._v("13")]),t("br"),t("span",{staticClass:"line-number"},[v._v("14")]),t("br"),t("span",{staticClass:"line-number"},[v._v("15")]),t("br"),t("span",{staticClass:"line-number"},[v._v("16")]),t("br"),t("span",{staticClass:"line-number"},[v._v("17")]),t("br"),t("span",{staticClass:"line-number"},[v._v("18")]),t("br"),t("span",{staticClass:"line-number"},[v._v("19")]),t("br"),t("span",{staticClass:"line-number"},[v._v("20")]),t("br")])])])},[],!1,null,null,null);a.default=_.exports}}]);