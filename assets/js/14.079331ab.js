(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{286:function(_,v,t){"use strict";t.r(v);var i=t(10),l=Object(i.a)({},function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h2",{attrs:{id:"计算机基础"}},[_._v("计算机基础")]),_._v(" "),t("h3",{attrs:{id:"汇编语言执行过程"}},[_._v("汇编语言执行过程")]),_._v(" "),t("ul",[t("li",[_._v("计算机通电")]),_._v(" "),t("li",[_._v("cpu读取内存中程序（电信号输入）")]),_._v(" "),t("li",[_._v("时钟发生器不断震荡通断电")]),_._v(" "),t("li",[_._v("推送cpu内部一步一步执行（执行多少步取决于指令需要的时钟周期）")])]),_._v(" "),t("h3",{attrs:{id:"cpu的基本组成"}},[_._v("CPU的基本组成")]),_._v(" "),t("ul",[t("li",[_._v("PC -> Program Counter 程序计数器(记录当前指令地址)")]),_._v(" "),t("li",[_._v("Registers -> 暂时存储CPU计算需要用到的数据")]),_._v(" "),t("li",[_._v("ALU ->Arithmetic & Logic Unit 运算和逻辑单元")]),_._v(" "),t("li",[_._v("CU ->Control Unit 控制单元")]),_._v(" "),t("li",[_._v("MMU ->Memory Management Unit 内存管理单元")]),_._v(" "),t("li",[_._v("cache ->")])]),_._v(" "),t("p",[t("img",{attrs:{src:"/img/computerBottom/computerBottom_1.pnf",alt:"computer_bottom"}})]),_._v(" "),t("h3",{attrs:{id:"存储器的层次结构"}},[_._v("存储器的层次结构")]),_._v(" "),t("p",[_._v("---- cpu 内部 -----")]),_._v(" "),t("ul",[t("li",[_._v("L0:寄存器  <1ns （cpu到该区域时间）")]),_._v(" "),t("li",[_._v("L1:高速缓存 约 1ns")]),_._v(" "),t("li",[_._v("L2:高速缓存 约 3ns\n---- cpu 共享 -----")]),_._v(" "),t("li",[_._v("L3:高速缓存  15ns")]),_._v(" "),t("li",[_._v("L4:主存   80ns")]),_._v(" "),t("li",[_._v("L5:磁盘")]),_._v(" "),t("li",[_._v("L6:远程文件存储")])]),_._v(" "),t("h3",{attrs:{id:"启动过程"}},[_._v("启动过程")]),_._v(" "),t("ul",[t("li",[_._v("通电")]),_._v(" "),t("li",[_._v("bios uefi工作")]),_._v(" "),t("li",[_._v("自检")]),_._v(" "),t("li",[_._v("到硬盘固定位置加载bootloader")]),_._v(" "),t("li",[_._v("读取可配置信息")]),_._v(" "),t("li",[_._v("CMOS（成像）")])]),_._v(" "),t("h3",{attrs:{id:"伪共享"}},[_._v("伪共享")]),_._v(" "),t("p",[_._v("伪共享的非标准定义为：缓存系统中是以缓存行（cache line）为单位存储的，\n当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，\n就会无意中影响彼此的性能，这就是伪共享")]),_._v(" "),t("h3",{attrs:{id:"缓存行对齐："}},[_._v("缓存行对齐：")]),_._v(" "),t("pre",[t("code",[_._v("对于有些特别敏感的数字，会存在线程高竞争的访问，为了保证不发生伪共享，可以使用缓存航对齐的编程方式\n\nJDK7中，很多采用long padding提高效率\n\nJDK8，加入了@Contended注解（实验）需要加上：JVM -XX:-RestrictContended\n")])]),_._v(" "),t("h3",{attrs:{id:"对象创建的过程"}},[_._v("对象创建的过程")]),_._v(" "),t("p",[t("img",{attrs:{src:"/img/computerBottom/computerBottom_2.png",alt:"computer_bottom"}})]),_._v(" "),t("ul",[t("li",[_._v("new 在内存申请空间")]),_._v(" "),t("li",[_._v("dup (duplicate 复制) 在栈里复制一份")]),_._v(" "),t("li",[_._v("invokespecial 弹出指向的对象 调用构造方法")]),_._v(" "),t("li",[_._v("store_1 VM从操作数栈顶部弹出一个引用类型或者returnAddress类型值，然后将该值存入由索引1指定的局部变量中,即将引用类型或者returnAddress类型值存入局部变量1")])]),_._v(" "),t("h3",{attrs:{id:"合并写"}},[_._v("合并写")]),_._v(" "),t("p",[_._v("Write Combining Buffer")]),_._v(" "),t("p",[_._v("一般是4个字节")]),_._v(" "),t("p",[_._v("由于ALU速度太快，所以在写入L1的同时，写入一个WC Buffer，满了之后，再直接更新到L2")]),_._v(" "),t("h3",{attrs:{id:"numa"}},[_._v("NUMA")]),_._v(" "),t("p",[_._v("Non Uniform Memory Access")]),_._v(" "),t("p",[_._v("ZGC - NUMA aware")]),_._v(" "),t("p",[_._v("分配内存会优先分配该线程所在CPU的最近内存")]),_._v(" "),t("h3",{attrs:{id:"进程-线程-纤程-中断"}},[_._v("进程 线程 纤程 中断")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("进程就是一个程序运行起来的状态，线程是一个进程中的不同的执行路径。")])]),_._v(" "),t("li",[t("p",[_._v("专业：进程是OS分配资源的基本单位，线程是执行调度的基本单位。")])])]),_._v(" "),t("p",[_._v("分配资源最重要的是：独立的内存空间，线程调度执行（线程共享进程的内存空间，没有自己独立的内存空间 只是分配的收独享一块内存区域(但是可能会同时使用)）")]),_._v(" "),t("ul",[t("li",[_._v("纤程：用户态的线程，线程中的线程，切换和调度不需要经过OS")])]),_._v(" "),t("p",[_._v("优势：1：占有资源很少 OS : 线程1M Fiber：4K 2：切换比较简单 3：启动很多个10W+")]),_._v(" "),t("h4",{attrs:{id:"线程在linux的实现"}},[_._v("线程在linux的实现")]),_._v(" "),t("ul",[t("li",[_._v("就是一个普通进程,只不过和其他进程共享资源")]),_._v(" "),t("li",[_._v("其他系统都有各自的所谓的LWP的实现 Light Weight Process")]),_._v(" "),t("li",[_._v("高层面理解:一个进程中不同的执行路线")])]),_._v(" "),t("h4",{attrs:{id:"jvm线程的实现"}},[_._v("jvm线程的实现")]),_._v(" "),t("ul",[t("li",[_._v("跑在用户态")]),_._v(" "),t("li",[_._v("jvm一个线程对应 os 的一个线程 要和内核打交道(切换废资源 寄存器 pc等需要调度 进程的冲突调度等)")])]),_._v(" "),t("h4",{attrs:{id:"fiber-纤程"}},[_._v("Fiber 纤程")]),_._v(" "),t("ul",[t("li",[_._v("用户态的线程,线程中的线程,切换和调用不需要通过os")]),_._v(" "),t("li",[_._v("优势 :")])]),_._v(" "),t("ul",[t("li",[_._v("占用资源很少 在OS中:线程1M Fiber:4K")]),_._v(" "),t("li",[_._v("切换比较简单")]),_._v(" "),t("li",[_._v("可以启动很多个 10W+")])]),_._v(" "),t("p",[_._v("目前2020 3 支持内置纤程的语言：Kotlin Scala Go Python(lib)... Java? （open jdk : loom）")]),_._v(" "),t("h4",{attrs:{id:"僵尸进程"}},[_._v("僵尸进程")]),_._v(" "),t("p",[_._v("ps -ef |grep fefuct\n父进程产生子进程后 ,会维护子进程的一个PCB结构,子进程退出后,\n由父进程释放 如果父进程没有释放,那么子进程成为一个僵尸进程")]),_._v(" "),t("h4",{attrs:{id:"孤儿进程"}},[_._v("孤儿进程")]),_._v(" "),t("p",[_._v("子进程结束之前,父进程已经退出\n孤儿进程会成会init进程的孩子,由一号进程维护")]),_._v(" "),t("h4",{attrs:{id:"jmm"}},[_._v("JMM")]),_._v(" "),t("p",[t("img",{attrs:{src:"/img/computerBottom/computerBottom_3.png",alt:"computer_bottom"}})]),_._v(" "),t("h3",{attrs:{id:"进程调度"}},[_._v("进程调度")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("2.6采用CFS调度策略：Completely Fair Scheduler")])]),_._v(" "),t("li",[t("p",[_._v("按优先级分配时间片的比例，记录每个进程的执行时间，如果有一个进程执行时间不到他应该分配的比例，优先执行")])]),_._v(" "),t("li",[t("p",[_._v("默认调度策略：")])])]),_._v(" "),t("ul",[t("li",[_._v("实时 （急诊） 优先级分高低 - FIFO (First In First Out)，优先级一样 - RR（Round Robin）")]),_._v(" "),t("li",[_._v("普通： CFS")])]),_._v(" "),t("h3",{attrs:{id:"中断"}},[_._v("中断")]),_._v(" "),t("p",[_._v("硬件跟操作系统内核打交道的一种机制")]),_._v(" "),t("p",[_._v("软中断（80中断） ==  系统调用")]),_._v(" "),t("p",[_._v("系统调用：int 0x80 或者 sysenter原语")]),_._v(" "),t("p",[_._v("通过ax寄存器填入调用号")]),_._v(" "),t("p",[_._v("参数通过bx cx dx si di传入内核")]),_._v(" "),t("p",[_._v("返回值通过ax返回")]),_._v(" "),t("h3",{attrs:{id:"内存管理的发展历程"}},[_._v("内存管理的发展历程")]),_._v(" "),t("p",[_._v("DOS时代 - 同一时间只能有一个进程在运行（也有一些特殊算法可以支持多进程）")]),_._v(" "),t("p",[_._v("windows9x - 多个进程装入内存 1：内存不够用 2：互相打扰")]),_._v(" "),t("p",[_._v("为了解决这两个问题，诞生了现在的内存管理系统：虚拟地址 分页装入 软硬件结合寻址")]),_._v(" "),t("ul",[t("li",[_._v("分页（内存不够用），内存中分成固定大小的页框（4K），把程序（硬盘上）分成4K大小的块，用到哪一块，加载那一块，加载的过程中，如果内存已经满了，会把最不常用的一块放到swap分区， 把最新的一块加载进来，这个就是著名的LRU算法")])]),_._v(" "),t("ul",[t("li",[_._v("LRU算法 LeetCode146题\nLeast Recently Used 最不常用")]),_._v(" "),t("li",[_._v("哈希表（保证 查找操作O(1)） + 链表 （保证 排序操作和新增操作 O(1)））")]),_._v(" "),t("li",[_._v("双向链表 （保证 左边指针 指向右边块）")])]),_._v(" "),t("ul",[t("li",[_._v("虚拟内存（解决相互打扰问题）")])]),_._v(" "),t("ul",[t("li",[_._v("DOS Win31 ... 互相干掉")]),_._v(" "),t("li",[_._v("为了保证互不影响 - 让进程工作在虚拟空间，程序中用到的空间地址不再是直接的物理地址，而是虚拟的地址，这样，A进程永远不可能访问到B进程的空间")]),_._v(" "),t("li",[_._v("虚拟空间多大呢？寻址空间 - 64位系统 2 ^ 64，比物理空间大很多 ，单位是byte")]),_._v(" "),t("li",[_._v("站在虚拟的角度，进程是独享整个系统 + CPU")]),_._v(" "),t("li",[_._v("内存映射：偏移量 + 段的基地址 = 线性地址 （虚拟空间）")]),_._v(" "),t("li",[_._v("线性地址通过 OS + MMU（硬件 Memory Management Unit）")])]),_._v(" "),t("ul",[t("li",[_._v("缺页中断（不是很重要）：\n需要用到页面内存中没有，产生缺页异常（中断），由内核处理并加载")])]),_._v(" "),t("h3",{attrs:{id:"zgc-不支持32位-不支持指针压缩"}},[_._v("ZGC 不支持32位 不支持指针压缩")]),_._v(" "),t("p",[_._v("算法叫做：Colored Pointer(根据指针颜色决定是否做一些事情)")]),_._v(" "),t("p",[_._v("GC信息记录在指针上，不是记录在头部， immediate memory use")]),_._v(" "),t("p",[_._v("42位指针 寻址空间4T JDK13 -> 16T 目前为止最大16T 2^44")]),_._v(" "),t("h3",{attrs:{id:"cpu如何区分一个立即数-和-一条指令"}},[_._v("CPU如何区分一个立即数 和 一条指令")]),_._v(" "),t("p",[_._v("总线内部分为：数据总线 地址总线 控制总线")]),_._v(" "),t("p",[_._v("地址总线目前：48位")]),_._v(" "),t("p",[_._v("颜色指针本质上包含了地址映射的概念")]),_._v(" "),t("h4",{attrs:{id:"进程"}},[_._v("进程")]),_._v(" "),t("p",[_._v("linux也称为task 是系统分配资源的基本单位\n进程描述符: PCB(Process Control BLock)")]),_._v(" "),t("h4",{attrs:{id:"内核线程"}},[_._v("内核线程")]),_._v(" "),t("p",[_._v("内核启动之后经常需要做一些后台操作，这些由Kernel Thread完成，只能在内核空间运行")])])},[],!1,null,null,null);v.default=l.exports}}]);